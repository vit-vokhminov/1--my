<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: ES: современность и будущее</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: Синтаксис</a></li>
        <li><a class="list-sub__link" href="#chapter3">Глава 3: Структура</a></li>
        <li><a class="list-sub__link" href="#chapter4">Глава 4: Управление асинхронными операциями</a></li>
        <li><a class="list-sub__link" href="#chapter5">Глава 5: Коллекции</a></li>
        <li><a class="list-sub__link" href="#chapter6">Глава 6: Дополнения к API</a></li>
    </ul>
</div>



<div class="linear" id="chapter2">

    <h2>Глава 1: ES: современность и будущее</h2>

    <p><b>Tранскомпиляции</b> - nрубо говоря, вы посредством специального инструмента преоб-
        разуете код ES6 в эквивалент (или нечто близкое к таковому),
        работающий в окружениях ES5.</p>

    <pre class="brush: js;">
        var foo = [1,2,3];
        var obj = {
            foo // означает 'foo: foo'
        };
        obj.foo; // [1,2,3]

        // А вот каким образом (примерно) он транскомпилируется:
        var foo = [1,2,3];
        var obj = {
            foo: foo
        };
        obj.foo; // [1,2,3]
    </pre>


</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: Синтаксис</h2>

    <p><b>Операторы Spread и Rest</b></p>

    <pre class="brush: js;">
        function foo(x,y,z) {
            console.log( x, y, z );
        }
        foo( ...[1,2,3] ); // 1 2 3
    </pre>

    <p>Когда оператор <code>...</code>  стоит перед массивом (или любым другим
        набором доступных для перебора значений, которые будут 
        рассматриваться в главе 3), он разделяет массив на отдельные 
        значения.</p>

    <p>Как правило, вариант, показанный в предыдущем фрагменте кода,
        используется, когда требуется превратить массив в набор 
        аргументов для вызова функции. В этом случае оператор <code>...</code>  дает более
        простую синтаксическую замену метода <code>apply(..)</code> , который 
        использовался с той же целью до появления ES6.</p>
        
    <pre class="brush: js;">
        foo.apply( null, [1,2,3] ); // 1 2 3    
    </pre>

    <p>Впрочем, оператор <code>...</code>  позволяет расширять значение и в других
        контекстах, например внутри объявления другого массива:</p>

    <pre class="brush: js;">
        var a = [2,3,4];
        var b = [ 1, ...a, 5 ];

        console.log( b ); // [1,2,3,4,5]
    </pre>

    <p>Кроме того, оператор <code>...</code>  повсеместно используется для 
        противоположной цели: вместо разделения массива он собирает набор
        значений в массив. Например:</p>

    <pre class="brush: js;">
        function foo(x, y, ...z) {
            console.log( x, y, z );
        }

        foo( 1, 2, 3, 4, 5 ); // 1 2 [3,4,5]
    </pre>

    <br>

    <p>Пример <code>rest</code> оператора:</p>

    <pre class="brush: js;">
        function foo(...args) {
            // 'args' это настоящий массив
            // отбрасываем первый элемент в массиве 'args'
            args.shift();
            // передаем все содержимое 'args' как аргументы
            // методу 'console.log(..)'
            console.log( ...args );
        }

        bar( 0, 1, 2, 3 ); // 2 4
    </pre>

    <br>

    <p><b>Значения параметров по умолчанию</b></p>

    <pre class="brush: js;">
        function foo(x = 11, y = 31) {
            console.log( x , y );
        }

        foo();                  // 11 31
        foo( 5, 6 );            // 5 6
        foo( 0, 42 );           // 0 42
        foo( 5 );               // 5 31
        foo( 5, undefined );    // 5 31 <-- 'undefined' отсутствует
        foo( 5, null );         // 5 null <-- null приводится к '0'
        foo( undefined, 6 );    // 11 6 <-- 'undefined' отсутств
    </pre>

    <br>

    <p><b>Выражения как значения по умолчанию</b></p>

    <pre class="brush: js;">
        function bar(val) {
            console.log( "bar called!" );
            return y + val;
        }

        function foo(x = y + 3, z = bar( x )) {
            console.log( x, z );
        }

        var y = 5;
        foo();          // "bar called"
                        // 8 13

        foo( 10 );      // "bar called"
                        // 10 15

        y = 6;
        foo( undefined, 10 );   // 9 10
    </pre>

    <br>

    <p><b>Деструктурирующее присваивание</b></p>

    <p>В ES6 добавлен специальный синтаксис
        для деструктурирующего присваивания, которое в числе прочего
        применимо к массивам и объектам.</p>

    <pre class="brush: js;">
        function foo() {
            return [1,2,3];
        }

        function bar() {
            return {
                x: 4,
                y: 5,
                z: 6
            };
        }

        var [ a, b, c ] = foo();
        var { x: x, y: y, z: z } = bar();

        console.log( a, b, c );         // 1 2 3
        console.log( x, y, z );         // 4 5 6
    </pre>

    <br>

    <p><b>Шаблон присваивания свойств объекта</b></p>

    <p>Если переменная создается с тем же именем, что
        и свойство объекта, можно сократить запись:</p>

    <pre class="brush: js;">
        var { x, y, z } = bar();
        console.log( x, y, z ); // 4 5 6
    </pre>

    <p>Используя сокращенный синтаксис, мы отбрасываем часть <code>x:</code> . 
        Другая запись позволяет
        присвоить значение переменной с другим именем, что в некоторых
        ситуациях может оказаться крайне полезным:</p>

    <pre class="brush: js;">
        var { x: bam, y: baz, z: bap } = bar();

        console.log( bam, baz, bap ); // 4 5 6
        console.log( x, y, z ); // ReferenceError
    </pre>

    <p>Oбъектные литералы создаются как <code>target <-- source</code>, в то время как 
        деструктурирующее присваивание объекта происходит по принципу 
        <code>source --> target</code>. Видите, как все переворачивается?</p>

    <br>

    <p><b>Не только в объявлениях</b></p>

    <pre class="brush: js;">
        var a, b, c, x, y, z;

        [a,b,c] = foo();
        ( { x, y, z } = bar() );

        console.log( a, b, c ); // 1 2 3
        console.log( x, y, z ); // 4 5 6
    </pre>

    <p>Если деструктурирующее присваивание объекта происходит <b>не
        внутри оператора <code>var/let/const</code></b>, все выражение присваивания
        следует поместить в круглые скобки <code>( )</code>, потому что в противном
        случае находящееся слева содержимое фигурных скобок <code>{ .   }</code>
        будет рассматриваться как блок, а не как объект </p>

    <pre class="brush: js;">
        var o1 = { a: 1, b: 2, c: 3 },
            o2 = {};

        ( { a: o2.x, b: o2.y, c: o2.z } = o1 );
        console.log( o2.x, o2.y, o2.z ); // 1 2 3


        //Можно преобразовать объект в массив, например так:
        var o1 = { a: 1, b: 2, c: 3 },
            a2 = [];

        ( { a: a2[0], b: a2[1], c: a2[2] } = o1 );
        console.log( a2 ); // [1,2,3]


        //Или сделать наоборот:
        var a1 = [ 1, 2, 3 ],
            o2 = {};

        [ o2.a, o2.b, o2.c ] = a1;
        console.log( o2.a, o2.b, o2.c ); // 1 2 3


        //Можно преобразовать один массив в другой:
        var a1 = [ 1, 2, 3 ],
            a2 = [];

        [ a2[2], a2[0], a2[1] ] = a1;
        console.log( a2 ); // [2,3,1]


        //Более того, традиционную задачу по обмену значениями двух 
        ///переменных можно решать, не прибегая к дополнительной переменной:
        var x = 10, y = 20;

        [ y, x ] = [ x, y ];
        console.log( x, y ); // 20 10
    </pre>

    <p>Будьте осторожны: не следует вставлять в объявления операцию
        присваивания, если только вы не хотите, чтобы как объявления
        рассматривались все выражения присваивания одновременно 
        В противном случае вы получите синтаксические ошибки  Именно
        по этой причине в вышеприведенном примере я отделил операцию
        <code>var a2 =[]</code>  от деструктурирующего присваивания <code>[ a2[0] , .   ] = .. </code> 
        Запись <code>var [ a2[0] , .   ] = </code>.   попросту не имеет смысла, так как
        <code>a2[0]</code>  — некорректный идентификатор объявления; кроме того,
        очевидно, что невозможно неявным образом создать объявление
        <code>var a2 =[]</code>  </p>

    <br>

    <p><b>Значения по умолчанию для деструктуризации
        и для параметров</b></p>

    <pre class="brush: js;">
        function f6({ x = 10 } = {}, { y } = { y: 10 }) {
            console.log( x, y );
        }

        f6();           // 10 10
        f6( {}, {} );   // 10 undefined
    </pre>

    <p>Запись <code>{ y: 10 }</code> означает объект как значение по 
        умолчанию параметра функции, а не как значение по умолчанию 
        деструктуризации и поэтому применимо только в случае, когда второй
        аргумент вообще не передается или передается как <code>undefined</code>.</p>
    
    <p>В предыдущем фрагменте кода мы передаем второй аргумент <code>({})</code> ,
        так что значение по умолчанию <code>{ y: 10 }</code> не используется и 
        деструктуризация <code>{ y }</code> возникает как функция значения переданного 
        пустого объекта <code>{}</code>.</p>

    <p>Теперь сравним <code>{ y } = { y: 10 } и { x = 10 } = {}</code>.</p>

    <p>Что касается варианта с переменной <code>x</code>, то, если аргумент первой
        функции опущен или имеет значение <code>undefined</code>, применяется 
        значение по умолчанию пустого объекта <code>{}</code>. Затем вне зависимости от
        того, какое значение оказалось в положении первого 
        аргумента — это может быть или значение по умолчанию <code>{}</code>, или значение, 
        которое передали вы, — выполняется его деструктуризация с учетом
        того, что <code>{ x = 10 }</code>. При этом ищется свойство <code>x</code>. Если обнаружить
        его не удается (или оно имеет значение <code>undefined</code>), именованный
        параметр x получает значение по умолчанию <code>10</code>.</p>

    <pre class="brush: js;">
        function f6({ x = 10 } = {}, { y } = { y: 10 }) {
            console.log( x, y );
        }

        f6();                           // 10 10
        f6( undefined, undefined );     // 10 10
        f6( {}, undefined );            // 10 10
        f6( {}, {} );                   // 10 undefined
        f6( undefined, {} );            // 10 undefined
        f6( { x: 2 }, { y: 3 } );       // 2 3
    </pre>

    <br>

    <p><b>Расширения объектных литералов</b></p>

    <p>Определение свойства, имя
        которого совпадает с лексическим идентификатором, можно 
        сократить с <code>x: x</code> до <code>x</code>. Смотрите:</p>

    <pre class="brush: js;">
        var x = 2, y = 3;
        var o = {
            x,
            y
        };
    </pre>        

    <p><b>Краткие методы</b></p>

    <pre class="brush: js;">
        var o = {
            x: function(){
                // . .
            },
            y: function(){
                // . .
            }
        }
        

        // А реализация в ES6 — так:
        var o = {
            x() {
                // . .
            },
            y() {
                // . .
            }
        }


        // У генераторов (см. главу 4) также есть сокращенная форма метода:
        var o = {
            *foo() { .. }
        };
    </pre>   

    <br>

    <p><b>Цикл for..of</b></p>

    <pre class="brush: js;">
        var a = ["a","b","c","d","e"];

        for ( var idx in a) {
            console.log( idx );
        }
        // 0 1 2 3 4


        for ( var val of a) {
            console.log( val );
        }
        // "a" "b" "c" "d" "e"


        for ( var c of "hello") {
            console.log( c );
        }
        // "h" "e" "l" "l" "o"
    </pre>

    <p>В выражении <code>for (XYZ of ABC)..</code>  часть <code>XYZ</code> может быть или 
        выражением присваивания, или объявлением, идентичным той же
        самой части в циклах <code>for</code> и <code>for..in</code>. Это позволяет делать вот такие
        вещи:</p>

    <pre class="brush: js;">
        var o = {};
        for (o.a of [1,2,3]) {
            console.log( o.a );
        }
        // 1 2 3

        console.log( o );       // {a: 3}
    </pre>

    <br>

    <p><b>Тип данных Symbol</b></p>

    <pre class="brush: js;">
        var sym = Symbol( "необязательное описание" );
        typeof sym; // "symbol"
    </pre>

    <p>Описание, если оно дается, используется исключительно для пере-
        вода представления символа в строку:</p>

    <pre class="brush: js;">
        sym.toString(); // "Symbol(какое-то необязательное описание)"
    </pre>

</div>

<div class="linear" id="chapter3">

    <h2>Глава 3: </h2>

    <p><b>Интерфейсы</b></p>

    <p>На момент написания книги раздел 25.1.1.2 спецификации ES6
        описывал интерфейс <code>Iterator</code> как отвечающий следующим требо-
        ваниям:</p>

    <pre class="brush: js;">
        Iterator [обязательные параметры]
            next() {метод}: загружает следующий IteratorResult
    </pre>

    <p>Два дополнительных параметра для расширения некоторых итераторов:</p>

    <pre class="brush: js;">
        Iterator [необязательные параметры]
            return() {метод}: останавливает итератор и возвращает
                IteratorResult
            throw() {метод}: сообщает об ошибке и возвращает IteratorResult
    </pre>

    <p>Интерфейс IteratorResult определен следующим образом:</p>

    <pre class="brush: js;">
        IteratorResult
            value {свойство}: значение на текущей итерации или 
                окончательное возвращаемое значение (не обязательно, если это 'undefined')
            done {свойство}: тип boolean, показывает состояние выполнения
    </pre>

    <br>

    <p><b>Экспорт членов API</b></p>

    <pre class="brush: js;">
        export function foo() {
            // . .
        }

        export var awesome = 42;

        var bar = [1,2,3];

        export { bar };


        // Другой способ реализации этого же экспорта:
        function foo() {
            // . .
        }

        var awesome = 42;
        var bar = [1,2,3];

        export { foo, awesome, bar };
    </pre>

    <p>Все это называется именованным экспортом (named exports), так
        как вы, по сути, экспортируете привязки имени переменных, функций и пр.</p>

    <p>Все, что вы не помечаете ключевым словом export, остается 
        закрытым внутри области видимости модуля. То есть, несмотря на
        то что запись var bar = ..  выглядит как объявление на верхнем
        уровне глобальной области видимости, на самом деле верхний
        уровень здесь — сам модуль; в модулях глобальной области 
        видимости просто нет.</p>

    <br>

    <p><b>Импорт членов API</b></p>

    <p>Для импорта конкретных именованных членов API модуля в область
        видимости верхнего уровня применяется следующий синтаксис:</p>

    <pre class="brush: js;">
        import { foo, bar, baz } from "foo";
    </pre>

    <p>Синтаксис <code>{ .   }</code> в данном случае напоминает синтаксис 
        объектного литерала или даже деструктуризации объекта  Но эта форма
        специально предназначена для моду</p>

    <p>Вы можете переименовать импортированные связанные идентификаторы:</p>

    <pre class="brush: js;">
        import { foo as theFooFunc } from "foo";
        theFooFunc();     
    </pre>

    <p>Если модуль обладает только результатами экспорта по умолчанию,
        которые вы хотите импортировать и привязать к идентификатору,
        можно по вашему выбору опустить <code>{ .. }</code> для этого связывания.
        Тогда синтаксис примет самую приятную и краткую форму:</p>

    <pre class="brush: js;">
        import foo from "foo";
        // или :
        import { default as foo } from "foo";
    </pre>

    <br>

    <p>при наличии у модуля соответствующего определения
        можно импортировать результаты экспорта по умолчанию вместе
        с результатами именованного экспорта. </p>

    <pre class="brush: js;">
        export default function foo() { .. }
        export function bar() { .. }
        export function baz() { .. }
    </pre>

    <p>Давайте импортируем результаты экспорта по умолчанию этого
        модуля и два результата именованного экспорта.</p>

    <pre class="brush: js;">
        import FOOFN, { bar, baz as BAZ } from "foo";

        FOOFN();
        bar();
        BAZ();
    </pre>

    <p>когда вы импортируете все содержимое модуля в одно
        пространство имен вместо импорта отдельных членов в область
        видимости. К счастью, у оператора <code>import</code> есть синтаксическая
        вариация, поддерживающая такой стиль работы с модулем. Она
        называется импортом пространства имен (<code>namespace import</code>).</p>

        <p>Допустим, модуль "foo" экспортируется следующим образом:</p>


    <pre class="brush: js;">
        export function bar() { .. }
        export var x = 42;
        export function baz() { .. }
    </pre>

    <p>Вы можете импортировать API целиком в единую привязку к пространству имен модуля:</p>

    <pre class="brush: js;">
        import * as foo from "foo";

        foo.bar();
        foo.x; // 42
        foo.baz();
    </pre>

    <p>Если модуль, который импортируется с помощью выражения
        <code>* as ..</code> , обладает результатом экспорта по умолчанию, этот 
        результат в указанном пространстве имен называется <code>default</code>. Можно
        дополнительно именовать импорт по умолчанию извне привязки
        пространства имен как идентификатор верхнего уровня. 
        Рассмотрим модуль "<code>world</code>", экспортированный следующим образом:</p>

    <pre class="brush: js;">
        export default function foo() { .. }
        export function bar() { .. }
        export function baz() { .. }
        

        // А это процедура импорта:
        import foofn, * as hello from "world";

        foofn();
        hello.default();
        hello.bar();
        hello.baz();
    </pre>   

    <br>

    <p>В ES6 появился ряд функциональных особенностей, помогающих
        структуризации кода.</p>

    <ul class="ul_num">
        <li>Итераторы предоставляют последовательный доступ к 
            данным или к операциям. Они могут использоваться новыми
            функциональными элементами, такими как цикл <code>for..of</code>
            и оператор <code>...</code> .</li>
        <li>Генераторы представляют собой функции, управляемые
            итератором и умеющие локально приостанавливать и 
            возобновлять свою работу. Они позволяют программно (и 
            интерактивно, через передачу сообщений <code>yield/next(..)</code> ) генерировать 
            значения, работа с которыми осуществляется
            посредством итераций.</li>
        <li>Модули дают возможность закрытой инкапсуляции деталей
            реализации при помощи открытых экспортируемых API.
            Определения модулей представляют собой экземпляры
            синглтонов на базе файлов, которые статически разрешаются во время 
            компиляции.</li>
        <li>Классы предоставляют более чистый синтаксис для кода на
            базе прототипов. Добавление ключевого слова <code>super</code>, кроме
            того, разрешило сложную ситуацию с относительными 
            ссылками в цепочке <code>[[Prototype]]</code> .</li>
    </ul>

</div>

<div class="linear" id="chapter4">

    <h2>Глава 4: Управление асинхронными операциями</h2>

    <p><b>Обещания</b></p>

    <p>Обещание можно представить и как слушателя, который позволя-
        ет вам подписаться на прослушивание события, дающего сигнал
        о завершении какой-либо задачи. Срабатывание возникает всего
        один раз, тем не менее его уместно рассматривать как событие.</p>

    <br>

    <p><b>Создание и использование обещаний</b></p>

    <p>Для получения экземпляра обещания используется конструктор <code>Promise(..)</code> :</p>

    <pre class="brush: js;">
        var p = new Promise( function(resolve,reject){
            // . .
        } );
    </pre>

    <p>В конструкторе <code>Promise(..)</code>  предусмотрены два параметра. Это
        функции, которые в общем случае называются <code>resolve(..)</code>
        и <code>reject(..)</code>  соответственно. Они используются следующим 
        образом.</p>

    <ul class="ul_num">
        <li>При вызове функции <code>reject(..)</code>  обещание отклоняется,
            а переданное в нее значение становится причиной для отказа.</li>
        <li>Вызов функции <code>resolve(..)</code>  без какого-либо значения или
            со значением, не являющимся обещанием, приводит к выполнению обещания.</li>
        <li>Если в вызываемую функцию <code>resolve(..)</code>  передается еще
            одно обещание, основное обещание просто заимствует его
            состояние (исполнение или отказ) — вне зависимости от того,
            мгновенным или окончательным оно является.</li>
    </ul>

    <p>Это можно преобразовать следующим образом:</p>

    <pre class="brush: js;">
        function ajax(url) {
            return new Promise( function pr(resolve,reject){
                // делаем запрос, в конечном счете вызываем
                // или 'resolve(..)', или 'reject(..)'
            } );
        }

        // . .
        ajax( "http://some.url.1" )
        .then(
            function fulfilled(contents){
                // обрабатываем успешное завершение 'contents'
            },
            function rejected(reason){
                // обрабатываем причину ошибки ajax
            }
        );
    </pre>
    
    <p>Методы <code>then(..)</code>  и <code>catch(..)</code>  автоматически конструируют и 
        возвращают еще один экземпляр обещания, получающий результат
        разрешения, роль которого может играть как значение, 
        возвращаемое после выполнения обещания, так и обработчик отказа.</p>

    <br>

    <p>Объекты thenable</p>

    <p><b>Обещания</b> — это истинные экземпляры конструктора <code>Promise(..)</code> .
        Но существуют еще и похожие на обещания объекты, которые 
        называются <code>thenable</code> и в общем случае могут взаимодействовать
        с механизмом обещаний.</p>

    <p>Термином <code>thenable</code> называется любой объект (или функция), 
        обладающий методом <code>then(..)</code>. Везде, где механизмы обещаний могут
        допустить и принять состояние истинного обещания, они могут
        обрабатывать и объекты <code>thenable</code>.</p>
</div>

<div class="linear" id="chapter5">

    <h2>Глава 5: Коллекции</h2>

    <pre class="brush: js;">
        var m = new Map();
        var x = { id: 1 },

        y = { id: 2 };

        m.set( x, "foo" );
        m.set( y, "bar" );

        m.get( x );         // "foo"
        m.get( y );         // "bar"  

        m.size;             // 2
        m.clear();
        m.size;             // 0
    </pre>

    <p>Единственный недостаток — отсутствие возможности использовать
        синтаксис доступа в виде квадратных скобок <code>[ ]</code>  для задания и 
        извлечения значений. Но с этой работой удовлетворительно справ-
        ляются методы <code>get(..)</code>  и <code>set(..)</code> .</p>

    <p>Для удаления элемента из карты применяется не оператор <code>delete</code>,
        а метод <code>delete(..)</code> .</p>

    <p>Разумеется, в конструкторе <code>Map(..)</code>  можно просто вручную задать
        список элементов (массив ключа / массивы значений):</p>

    <pre class="brush: js;">
        var x = { id: 1 },
        y = { id: 2 };

        var m = new Map( [
            [ x, "foo" ],
            [ y, "bar" ]
        ] );

        m.get( x ); // "foo"
        m.get( y ); // "bar"
    </pre>
</div>

<div class="linear" id="chapter6">

    <h2>Глава 6: Дополнения к API</h2>

    <p><b>Статическая функция Array.of(..)</b></p>

    <pre class="brush: js;">
        var a = Array( 3 );
        a.length; // 3
        a[0]; // undefined
        
        var b = Array.of( 3 );
        b.length; // 1
        b[0]; // 3

        var c = Array.of( 1, 2, 3 );
        c.length; // 3
        c; // [1,2,3]
    </pre>   

    <p>При каких обстоятельствах нам может потребоваться метод Array.</p>

    <ul class="ul_num">
        <li>
            Во-первых, это наличие обратного вызова, который должен охватывать 
            переданный в массив аргумент или аргументы. Метод <code>Array</code>.
            <code>of(..)</code> идеально подходит под такие условия. Это не очень 
            распространенная ситуация, но порой возникает именно такая необходимость.
        </li>
        <li>
            Второй случай — наличие производного класса Array, в экземпляре которого вы хотите создавать
            и инициализировать элементы.
        </li>
    </ul>

    <pre class="brush: js;">
        class MyCoolArray extends Array {
            sum() {
                return this.reduce( function reducer(acc,curr){
                return acc + curr;
                }, 0 );
            }
        }

        var x = new MyCoolArray( 3 );

        x.length;           // 3 - ой!
        x.sum();            // 0 - ой!

        var y = [3];        // Array, не MyCoolArray
        y.length;           // 1
        y.sum();            // 'sum' - это не функция

        var z = MyCoolArray.of( 3 );
        z.length;           // 1
    </pre>
</div>


<!--
<code></code>
<p></p>
<p><b></b></p>

<pre class="brush: js;">
        
</pre>

<div class="linear" id="chapter5">

    <h2>Глава 5: </h2>


</div>

<ul class="ul_num">
    <li></li>
</ul>

Разрешение экрана:
ширина: 1280 - 1264
высота: 800
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
