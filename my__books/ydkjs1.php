<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: Введение в программирование</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: Введение в JavaScript</a></li>
    </ul>
</div>



<div class="linear" id="chapter1">

    <h2>Глава 1: Введение в программирование</h2>

    <br>

    <p><b><i>Переменные</i></b> хранят <b><i>значения</i></b> (например, число 42)</p>

    <br>

    <p><b>Операторы</b></p>

    <p><b><i>Оператор</i></b> это группа слов, чисел и операций, которые выполняют
        определенную задачу</p>

    <pre class="brush: js;">
        a = b * 2;
    </pre>

    <p><b><i>Литеральное значение</i></b> это просто значение: <i>2, 'строка'</i></p>

    <p><b><i>Операции</i></b> = + - / *</p>

    <p><b><i>Программы</i></b> — это всего лишь набор стольких операторов, сколько нужно для того, чтобы
        описать все шаги, необходимые для выполнения цели вашей программы.</p>

    <br>

    <p><b>Выражения</b></p>

    <p><b><i>Выражение</i></b> — это любая ссылка на
        переменную или значение или набор переменных и значений, объединенных операциями.</p>

    <p><code>a = b * 2;</code></p>

    <p>У этого оператора 4 выражения:</p>

    <ul class="ul_num">
        <li><code>2</code> — это выражение литерального значения</li>
        <li><code>b</code> — это выражение переменной, которое тут означает извлечение его текущего значения</li>
        <li><code>b * 2</code> — это арифметическое выражение, в данном случае выполнение умножения</li>
        <li><code>a = b * 2</code> — это выражение присваивания, в данном случае это присвоить результат
            выражения <code>b * 2</code> переменной <code>a</code></li>
    </ul>

    <br>

    <p><b><i>Интерпретатор или Компилятор</i></b> используются для перевода кода, который ты пишешь, в команды, понятные компьютеру.</p>

    <p>Движок JavaScript на самом деле компилирует программу на лету и затем сразу же запускает
        скомпилированный код.</p>

    <p><code>console.log(..)</code></p>

    <ul class="ul_num">
        <li><code>log(..)</code> — указывает на вызов функции</li>
        <li><code>console</code> — это ссылка на объект, где расположена функция <code>log(..)</code></li>
    </ul>

    <br>

    <p><b>Операции</b></p>

    <p><b><i>Операции</i></b> — это те действия, которые мы выполняем над переменными и значениями. Мы
        уже видели две операции JavaScript, <code>=</code> и <code>*</code></p>

    <p><b>Базовых операций в JavaScript:</b></p>

    <ul class="ul_num">
        <li><b><i>Присваивание</i></b>: <code>=</code> как в <code>a = 2</code>.</li>
        <li><b><i>Математические</i></b>: <code>+</code> (сложение), <code>-</code> (вычитание), <code>*</code> (умножение) и <code>/</code> (деление), как в <code>a * 3</code>.</li>
        <li><b><i>Составное присваивание</i></b>: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> — это составные операции, которые
            объединяют математическую операцию с присваиванием, как <code> a += 2</code> (эквивалентно
            <code>a = a + 2</code>).</li>
        <li><b><i>Инкремент/Декремент</i></b>: <code>++</code> (инкремент), <code>--</code> (декремент), как в <code>a++</code> (эквивалентно <code>a = a + 1</code>).</li>
        <li><b><i>Доступ к свойству объекта</i></b>: <code>.</code> как в <code>console.log()</code><br>
            <b>Объекты</b> — это значения, которые хранят другие значения под своими именами,
            называемые свойства. <code>obj.a</code> означает значение из объекта <code>obj</code> из его свойства <code>a</code>. Еще
            один способ доступа к свойствам — <code>obj["a"]</code>
            <pre class="brush: js;">
                значение: {
                    свойство: значение,
                    свойство: значение,
                }
            </pre>
        </li>
        <li><b><i>Равенство</i></b>: <code>==</code> (нестрогое), <code>===</code> (строгое), <code>!=</code> (нестрогое неравенство), <code>!==</code> (строгое
            неравенство), как в <code>a == b</code>.</li>
        <li><b><i>Сравнение</i></b>: <code><</code> (меньше чем), <code>></code> (больше чем), <code><=</code> (меньше или нестрого равно), <code>>=</code>
            (больше или нестрого равно), как в <code>a <= b</code>.</li>
        <li><b><i>Логические</i></b>: <code>&&</code> (и), <code>||</code> (или), как в <code>a || b</code>, которое выбирает или <code>a</code>, или <code>b</code>. Используются для создания составных условных конструкций</li>
    </ul>

    <p><b>Значения и типы</b></p>

    <p><i>Представления</i> для значений называются <b><i>типы</i></b>. Есть встроенные типы для каждого из этих так называемых
        примитивных значений:</p>

    <ul class="ul_num">
        <li>Когда нужно работать с математикой, нужно число.</li>
        <li>Когда нужно вывести значение на экран, нужна строка.</li>
        <li>Когда нужно принять решение в программе, нужно логическое значение
            (<code>true</code> (истина) или <code>false</code> (ложь)).</li>
    </ul>

    <p>Значения, непосредственно включаемые в исходный код, называются <b><i>литералы</i></b>. <i>Cтроковые</i>
        литералы заключаются в двойные кавычки "..." или одинарные '...'. <i>Литералы числа и логического
            зачения</i> пишутся как есть (42, true, false).</p>

    <p>Кроме типов значений <i>строка/число/логическое значение</i>, для языков программирования
        привычно предоставлять такие типы как <i>массивы, объекты, функции</i> и многое другое.</p>

    <br>

    <p><b>Переменные</b></p>

    <p>Первичную цель переменных: управление состоянием программы.</p>

    <p><b><i>Cостояние</i></b> отслеживает изменения значений при выполнении программы.</p>

    <br>

    <p><b>Блоки</b></p>

    <p>Блок определяется обрамлением одного или более операторов парой фигурных скобок <code>{ .. }</code></p>

    <p>Блоковый оператор не требует точки с запятой <code>;</code> в конце оператора</p>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: Введение в JavaScript</h2>

    <p><b>Выражения немедленно вызываемых функций</b></p>

    <pre class="brush: js;">
        (function IIFE(){
            console.log( "Hello!" );
        })();
        // "Hello!"
    </pre>

    <p>Внешние <code>( .. )</code>, которые окружают выражение функции <code>(function IIFE(){ .. })</code> — это
        всего лишь нюанс грамматики JS, необходимый для предотвращения того, чтобы это
        выражение воспринималось как объявление обычной функции.</p>

    <p>Последние <code>()</code> в конце выражения, строка <code>})();</code> — это то, что запускает функцию</p>

    <p>функции создают область видимости переменных, то
        использование <code>IIFE</code> таким образом обычно происходит, чтобы объявлять переменные,
        которые не будут влиять на код, окружающий <code>IIFE</code> снаружи:</p>

    <pre class="brush: js;">
        var a = 42;
        (function IIFE(){
            var a = 10;
            console.log( a ); // 10
        })();
        console.log( a ); // 42
    </pre>

    <p>Функции <code>IIFE</code> также могут возвращать значения:</p>

    <pre class="brush: js;">
        var x = (function IIFE(){
            return 42;
        })();
        x; // 42
    </pre>

    <br>

    <p><b>Замыкание</b></p>

    <p>Замыкания — это модульный шаблон</p>

    <pre class="brush: js;">
        function makeAdder(x) {
            // параметр `x` - внутренная переменная
            // внутренняя функция `add()` использует `x`, поэтому
            // у нее есть "замыкание" на нее
            function add(y) {
                return y + x;
            };
            return add;
        }


        // `plusOne` получает ссылку на внутреннюю функцию `add(..)`
        // с замыканием на параметре `x`
        // внешней `makeAdder(..)`
        var plusOne = makeAdder( 1 );
        // `plusTen` получает ссылку на внутреннюю функцию `add(..)`
        // с замыканием на параметре `x`
        // внешней `makeAdder(..)`
        var plusTen = makeAdder( 10 );
        plusOne( 3 ); // 4       3 + 1
        plusOne( 41 ); // 42     41 + 1
        plusTen( 13 ); // 23     13 + 10
    </pre>

    <p>Теперь подробней о том, как работает этот код:</p>

    <ul class="ul_num">
        <li>Когда мы вызываем <code>makeAdder(1)</code>, мы получаем обратно ссылку на ее внутреннюю
            <code>add(..)</code>, которая запоминает <code>x</code> как <code>1</code>. Мы назвали эту ссылку на функцию
            <code>plusOne(..)</code>.</li>
        <li>Когда мы вызываем <code>makeAdder(10)</code>, мы получаем обратно ссылку на ее внутреннюю
            <code>add(..)</code>, которая запоминает <code>x</code> как <code>10</code>. Мы назвали эту ссылку на функцию
            <code>plusTen(..)</code>.</li>
        <li>Когда мы вызываем <code>plusOne(3)</code>, она прибавляет <code>3</code> (свою внутреннюю y) к <code>1</code> (которая
            запомнена в <code>x</code>) и мы получаем в качестве результата <code>4</code>.</li>
        <li>Когда мы вызываем <code>plusTen(13)</code>, она прибавляет <code>13</code> (свою внутреннюю <code>y</code>) к <code>10</code>
            (которая запомнена в <cpde>x</cpde>), и мы получаем в качестве результата <code>23</code>.</li>
    </ul>

    <br>

    <p><b>Модули</b></p>

    <pre class="brush: js;">
       function User(){
            var username, password;
            function doLogin(user,pw) {
                username = user;
                password = pw;
                // сделать остальную часть работы по логину
            }
            var publicAPI = {
                login: doLogin
            };
            return publicAPI;
        }
        // создать экземпляр модуля `User`
        var fred = User();
        fred.login( "fred", "12Battery34!" );
    </pre>

    <p>Функция <code>User()</code> служит как внешняя область видимости, которая хранит переменные
        username и <code>password</code>, а также внутреннюю функцию <code>doLogin()</code>. Всё это частные внутренние
        детали этого модуля <code>User</code>, которые недоступны из внешнего мира</p>

    <br>

    <p><b>this</b></p>

    <p>Если у функции есть внутри ссылка <code>this</code>, эта ссылка <code>this</code> обычно указывает на объект. Но на
        какой объект она указывает зависит от того, как эта функция была вызвана</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.bar );
        }

        var bar = "global";

        var obj1 = {
            bar: "obj1",
            foo: foo
        };

        var obj2 = {
            bar: "obj2"
        };

        //--------
        foo(); // "global"
        obj1.foo(); // "obj1"
        foo.call( obj2 ); // "obj2"
        new foo(); // undefined
    </pre>

    <p>Есть четыре правила того, как устанавливается <code>this</code> и они показаны в этих четырех
        последних строках кода</p>

    <ul class="ul_num">
        <li><code>foo()</code> заканчивается установкой <code>this</code> в глобальный объект в нестрогом режиме. В
            строгом режиме, <code>this</code> будет <code>undefined</code> и вы получите ошибку при доступе к свойству
            <code>bar</code>, поэтому <code>"global"</code> — это значение для <code>this.bar</code>.</li>
        <li><code>obj1.foo()</code> устанавливает <code>this</code> в объект <code>obj1</code>.</li>
        <li><code>foo.call(obj2)</code> устанавливает <code>this</code> в объект <code>obj2</code>.</li>
        <li><code>new foo()</code> устанавливает <code>this</code> в абсолютно новый пустой объект.</li>
    </ul>

    <br>

    <p><b>Прототипы</b></p>

    <p>Когда вы ссылаетесь на свойство объекта, то если это свойство не существует, JavaScript
        автоматически использует ссылку на внутренний прототип этого объекта, чтобы найти
        другой объект, чтобы поискать свойство там.</p>

    <pre class="brush: js;">
        var foo = {
            a: 42
        };

        // создаем `bar` и связываем его с `foo`

        var bar = Object.create( foo );
        bar.b = "hello world";
        bar.b; // "hello world"
        bar.a; // 42 <-- делегируется в `foo`
    </pre>

    <br>

    <p><b>Старый и новый</b></p>

    <p>Есть две основные техники, которыми можно пользоваться, чтобы "привнести" более новые
        возможности JavaScript в старые браузеры: полифиллинг (<code>polyfilling</code>) и транспиляция
        (<code>transpiling</code>)</p>

    <p><b>Полифиллинг (polyfilling)</b></p>

    <p>Например, <code>ES6</code> определяет функцию, называемую <code>Number.isNaN(..)</code> для обеспечения точной
        безошибочной проверки на значения <code>NaN</code>, отмечая как устаревшую исходную функцию
        <code>isNaN(..)</code>. Но очень легко заполифиллить эту функцию, чтобы вы могли пользоваться ею в
        вашем коде независимо от того, поддерживает браузер <code>ES6</code> или нет.</p>

    <pre class="brush: js;">
    if (!Number.isNaN) {
        Number.isNaN = function isNaN(x) {
                return x !== x;
        };
    }
    </pre>

    <p>Оператор <code>if</code> защищает против применения полифильного определения в браузерах с <code>ES6</code>, где
        функция уже есть. Если она еще не существует, мы определяем <code>Number.isNaN(..)</code></p>

    <p>Проверка, которую мы тут выполняем, использует преимущество
        причудливости значения <code>NaN</code>, которое заключается в том, что оно является единственным
        значением во всем языке, которое не равно самому себе. Поэтому значение <code>NaN</code> —
        единственное, которое может сделать условие <code>x !== x</code> истинным</p>

    <br>

    <p><b>Транспиляция (Transpiling)</b></p>

    <p>Не существует возможности полифиллить новый синтаксис, который был добавлен в язык. Поэтому лучшим выбором будет использовать утилиту, которая конвертирует ваш более
        новый код в эквивалент более старого. Этот процесс обычно называют "транспиляцией", как
        объединение терминов трансформация и компиляция (transforming + compiling)</p>

    <p>Есть довольно много отличных транспиляторов для выбора:</p>

    <ul class="ul_num">
        <li><b><i>Babel</i></b> (https://babeljs.io) (бывший 6to5): Транспилирует из ES6+ в ES5</li>
        <li><b><i>Traceur</i></b> (https://github.com/google/traceur-compiler): Транспилирует из ES6, ES7 и далее
            в ES5</li>
    </ul>

    <br>

    <p><b>Не-JavaScript</b></p>

    <pre class="brush: js;">
        var el = document.getElementById( "foo" );
    </pre>

    <p>Переменная <code>document</code> существует как глобальная переменная, когда ваш код выполняется в
        браузере. Она не обеспечивается ни движком <code>JS</code>, ни особенно не контролируется
        спецификацией <code>JavaScript</code>. Она принимает форму чего-то очень ужасного похожего на
        обычный <code>JS</code> объект, но не является им на самом деле. Это — специальный объект, часто
        называемый <code>"хост-объектом."</code></p>

    <p>Более того, метод <code>getElementById(..)</code> в document выглядит как обычная функция <code>JS</code>, но это
        всего лишь кое-как открытый интерфейс к встроенному методу, предоставляемому <code>DOM</code> из
        вашего браузера. В некоторых (нового поколения) браузерах этот слой может быть на <code>JS</code>, но
        традиционно <code>DOM</code> и его поведение реализовано на чем-то вроде <code>C/C++</code>.</p>
</div>


<!--
<pre class="brush: js;">

</pre>



<ul class="ul_num">
    <li></li>
</ul>
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
