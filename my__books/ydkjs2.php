<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: Область видимости и замыкания</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: Лексическая область видимости</a></li>
        <li><a class="list-sub__link" href="#chapter3">Глава 3: Функциональные и блочные области видимости</a></li>
        <li><a class="list-sub__link" href="#chapter4">Глава 4: Поднятие</a></li>
        <li><a class="list-sub__link" href="#chapter5">Глава 5: Замыкание области видимости</a></li>
    </ul>
</div>



<div class="linear" id="chapter1">

    <h2>Глава 1: Область видимости и замыкания</h2>

    <p>Область видимости — набор правил, определяющих, где и как
        осуществляется поиск переменной (идентификатора). Поиск
        может выполняться для цели присваивания переменной (<code>LHS</code>,
        или левосторонняя ссылка) или же для цели чтения ее значения
        (<code>RHS, или правосторонняя ссылка</code>).</p>

    <p><code>LHS-ссылки</code> появляются в результате операций присваивания.
        Присваивания, связанные с областью видимости, могут происходить либо в операторе <code>=</code>, либо при передаче аргументов параметрам функции.</p>

    <p>Движок JavaScript сначала компилирует код перед выполнением.</p>

    <p>При этом команды вида <code>var a = 2;</code> разбиваются на две части:</p>

    <ul class="ul_num">
        <li>Сначала <code>var a</code> для объявления переменной в области видимости. Этот шаг выполняется перед выполнением кода.</li>
        <li>Потом <code>a = 2</code> для поиска переменной (<code>LHS-ссылка</code>) и присваивания ей, если переменная будет успешно найдена.</li>
    </ul>

    <p> Поиск по <code>LHS- и RHS-ссылкам</code> начинается с текущей области
        видимости. При необходимости (то есть если искомый идентификатор не будет найден) поиск поднимается вверх от вложенной
        области видимости, по одной области видимости (этажу) за раз,
        пока не доберется до глобальной области видимости (верхнего
        этажа). Здесь поиск останавливается: либо идентификатор найден,
        либо нет.</p>

   <p>Для неразрешенных <code>RHS-ссылок</code> выдается исключение <code>ReferenceError</code>. Для неразрешенных <code>LHS-ссылок</code> автоматически создается глобальная переменная с заданным именем (если не действует режим <code>strict</code>), или происходит ошибка <code>ReferenceError</code>
       (в режиме <code>strict</code>)</p>

    <pre class="brush: js;">
        //1. Найдите все LHS-поиски (всего 3).
        //2. Найдите все RHS-поиски (всего 4).

        function foo(a) {
            var b = a;
            return a + b;
        }
        var c = foo( 2 );

        //  c = ..;, a = 2 (неявное присваивание параметра) и b = ..
        //  foo(2), = a;, a .. и .. b
    </pre>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: Лексическая область видимости</h2>

    <p>Лексическая область видимости определяется решениями о том,
        где объявляются функции, принимаемыми во время написания
        программы. Фаза лексического анализа в процессе компиляции
        располагает информацией о том, где и как объявлены все идентификаторы, — а следовательно, может спрогнозировать их поиск
        во время выполнения.</p>

    <p>В JavaScript существуют два механизма, которые могут «исказить»
        лексическую область видимости: <code>eval(..)</code> и <code>with</code>. Первый может
        изменить существующую лексическую область видимости (во
        время выполнения), обрабатывая строку «кода» с одним или несколькими объявлениями. Второй фактически создает новую
        лексическую область видимости (снова во время выполнения),
        интерпретируя ссылку на объект как область видимости, а свойства этого объекта — как идентификаторы в области видимости.</p>

    <p>Недостаток этих механизмов заключается в том, что они не позволяют движку выполнить оптимизации на стадии компиляции,
        связанные с поиском по областям видимости, потому что движок
        вынужден пессимистично считать, что такие оптимизации будут
        недействительными. При использовании любой из этих возможностей программа будет работать медленнее. Не используйте их.</p>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 3: Функциональные и блочные области видимости</h2>

    <p><b>Анонимные и именованные функциональные выражения</b></p>

    <pre class="brush: js;">
        setTimeout( function(){
            console.log("I waited 1 second!");
        }, 1000 );
    </pre>

    <p>Это называется <b><i>анонимным функциональным выражением</i></b>, потому
        что <code>function()…</code> не содержит идентификатор. Функциональные
        выражения могут быть анонимными, но могут возникнуть проблемы при отладке. Поэтому лучше всегда использовать имя функции.</p>

    <pre class="brush: js;">
        setTimeout( function timeoutHandler(){      // <-- Смотрите, у меня есть имя!
            console.log( "I waited 1 second!" );
        }, 1000 );
    </pre>

    <br>

    <p><b>Немедленный вызов функциональных выражений</b></p>

    <pre class="brush: js;">
        var a = 2;

        (function foo(){
            var a = 3;
            console.log( a ); // 3
        })();

        console.log( a ); // 2
    </pre>

    <p>У традиционной формы IIFE существует небольшая вариация,
        которую предпочитают некоторые разработчики: <code>(function()
            { .. }())</code>. Внимательно присмотритесь к различиям. В первой
        форме функциональное выражение заключается в круглые скобки <code>()</code>, за которыми размещается вызывающая пара круглых скобок
        <code>()</code>. Во второй форме вызывающие круглые скобки <code>()</code> перемещаются внутрь внешней пары <code>()</code>. Эти две формы имеют идентичную
        функциональность. Выбор определяется исключительно стилистическими предпочтениями.</p>

    <pre class="brush: js;">
        var a = 2;

        (function IIFE( global ){
            var a = 3;
            console.log( a ); // 3
            console.log( global.a ); // 2
        })( window );

        console.log( a ); // 2
    </pre>

    <p>Здесь передается ссылка на объект <code>window</code>, но параметру присваивается имя <code>global</code>, чтобы в программе существовало четкое
        стилистическое разграничение между глобальными и неглобальными ссылками. Конечно, вы можете передать все что угодно из
        внешней области видимости, и параметру можно будет присвоить любое подходящее имя. В основном это чисто стилистический выбор</p>

    <br>

    <p>Функция — самая распространенная структурная единица области
        видимости в JavaScript. Переменные и функции, объявленные
        внутри другой функции, по сути «скрываются» от всех внешних
        областей — сознательное применение принципа проектирования
        качественных программных продуктов.</p>

    <p>Однако функции никоим образом не являются единственной
        структурной единицей областей видимости. Под термином «блочная область видимости» понимается концепция принадлежности переменных и функций произвольному блоку (в общем случае
        любой паре <code>{..}</code>), а не только внешней функции.</p>

    <p>Начиная с <code>ES3</code> структура <code>try/catch</code> имеет блочную область видимости в секции <code>catch</code>.</p>

    <p>В <code>ES6</code> появилось ключевое слово <code>let</code> (родственник ключевого
        слова <code>var</code>), которое позволяет объявлять переменные в произвольном блоке кода. <code>if (..) { let a = 2; }</code> объявит переменную, которая фактически заимствует область видимости блока <code>if’s { .. }</code>
        и присоединяет себя к ней.</p>

    <p>Вопреки мнению некоторых разработчиков, блочную область
        видимости не следует воспринимать как прямую замену функциональной области видимости <code>var</code>. Обе возможности мирно сосуществуют, и разработчики могут и должны использовать как функциональную, так и блочную область видимости там, где это
        уместно, для создания более качественного, понятного и простого в сопровождении кода.</p>

    <p>Ключевое слово <code>const</code>, которое также
        создает константу, «переменную» с блочной областью видимости,
        значение которой остается фиксированным. Любая попытка изменить это значение в будущем приводит к ошибке</p>
</div>

<div class="linear" id="chapter4">

    <h2>Глава 4: Поднятие</h2>

    <p>Конструкции вида <code>var a = 2;</code> было бы заманчиво рассматривать
        как одну команду, но движок JavaScript рассматривает ее иначе.
        Он считает <code>var a</code> и <code>a = 2</code> двумя разными командами: первая обрабатывается во время компиляции, а вторая — во время выполнения.</p>

    <pre class="brush: js;">
        a = 2;
        var a;
        console.log( a );       // 2

        // фрагмент обрабатывается так:
        var a;
        a = 2;
        console.log( a );       // 2
    </pre>

    <pre class="brush: js;">
        console.log( a );
        var a = 2;              // undefined

        // фрагмент обрабатывается так:
        var a;
        console.log( a );       // undefined
        a = 2;
    </pre>

    <p>Поднимаются только сами объявления, а все присваивания и другая исполняемая логика остаются на своих местах. </p>

    <pre class="brush: js;">
        foo();
        function foo() {
            console.log( a );   // undefined
            var a = 2;
        }

        // фрагмент обрабатывается так:
        function foo() {
            var a;
            console.log( a );   // undefined
            a = 2;
        }
        foo();
    </pre>

    <p>Объявления функций поднимаются, функциональные выражения — нет.</p>

    <p>Также следует напомнить, что хотя это именованное функциональное выражение, идентификатор недоступен во внешней области видимости:</p>

    <pre class="brush: js;">
        foo();      // TypeError
        bar();      // ReferenceError
        var foo = function bar() {
            // ...
        };

        // фрагмент обрабатывается так:
        var foo;
        foo();      // TypeError
        bar();      // ReferenceError
        foo = function() {
            var bar = ...self...
            // ...
        }
    </pre>

    <p>Все это приводит к тому, что все объявления находятся в области
        видимости независимо от того, в какой точке они находятся, и обрабатываются заранее до выполнения самого кода. Это можно
        представить себе так, словно объявления (переменных и функций)
        «перемещаются» вверх своих соответствующих областей видимости; этот процесс называется поднятием. Поднимаются сами
        объявления, но присваивания (и даже присваивания функциональных выражений) не поднимаются.</p>

    <p>Будьте внимательны с дублирующимися объявлениями, особенно в комбинациях нормальных объявлений и объявлений функций, здесь вас поджидает опасность!</p>

</div>

<div class="linear" id="chapter5">

    <h2>Глава 5: Замыкание области видимости</h2>

    <p><code><b>Замыкание</b> — способность функции запоминать свою лексическую область видимости и обращаться к ней даже тогда, когда
            функция выполняется вне своей лексической области видимости.</code></p>

    <pre class="brush: js;">
        function foo() {
            var a = 2;
                function bar() {
                console.log( a );
            }
            return bar;
        }
        var baz = foo();
        baz(); // 2 -- Вы только что увидели замыкание.
    </pre>

    <p>Функция <code>bar()</code> обладает доступом лексической области видимости к внутренней области видимости <code>foo()</code>. Но затем мы берем
        <code>bar()</code> (саму функцию) и передаем ее как значение. В этом случае
        <code>return</code> возвращает сам объект функции, на который ссылается <code>bar</code></p>

    <p>После выполнения <code>foo()</code> возвращенное значение (наша внутренняя функция <code>bar()</code>) присваивается переменной с именем <code>baz</code>,
        после чего происходит вызов <code>baz()</code>, что, естественно, означает
        вызов нашей внутренней функции <code>bar()</code>, просто по другому идентификатору</p>

    <p>Функция <code>bar()</code> обладает
        замыканием лексической области видимости над внутренней областью видимости <code>foo()</code>. Поэтому данная область видимости
        продолжает существовать для <code>bar()</code>, что позволяет обратиться
        к ней в любой последующий момент времени.</p>

    <p><code>bar()</code> все еще содержит ссылку на эту область видимости, и эта ссылка называется <b>замыканием</b></p>

    <pre class="brush: js;">
        var fn;

        function foo() {
            var a = 2;
            function baz() {
                console.log( a );
            }
            fn = baz;       // baz присваивается глобальной переменной
        }

        function bar() {
            fn();       // смотрите, замыкание!
        }
        foo();
        bar();      // 2
    </pre>

    <p>Какой бы механизм ни использовался для транспортировки внутренней функции за пределы ее области видимости, она поддерживает ссылку на область видимости, в которой была изначально
        объявлена, — и при каждом ее выполнении будет задействована
        эта ссылка.</p>

    <p><b>Циклы и замыкания</b></p>

    <pre class="brush: js;">
        for (var i=1; i<=5; i++) {
            (function(j){
                setTimeout( function timer(){
                    console.log( j );
                }, j*1000 );
            })( i );
        }
        // 1 2 3 4 5
    </pre>

    <pre class="brush: js;">
        // или как то так
        for (let i=1; i<=5; i++) {
            setTimeout( function timer(){
                console.log( i );
            }, i*1000 );
        }
    </pre>

    <p><b>Модули</b></p>

    <pre class="brush: js;">
        function CoolModule() {
            var something = "cool";
            var another = [1, 2, 3];

            function doSomething() {
                console.log( something );
            }

            function doAnother() {
                console.log( another.join( " ! " ) );
            }

            return {
                doSomething: doSomething,
                doAnother: doAnother
            };
        }

        var foo = CoolModule();

        foo.doSomething(); // cool
        foo.doAnother(); // 1 ! 2 ! 3
    </pre>

    <p>Этот паттерн JavaScript называется <b>модулем</b>. Самый распространенный способ реализации паттерна «модуль» часто называется
        предоставлением (revealing) модуля; именно эта разновидность
        представлена выше</p>

    <p><code>CoolModule()</code> — всего лишь функция, <b><i>но она должна
        быть вызвана для создания экземпляра модуля. Без выполнения
                внешней функции создания внутренней области видимости и замыканий не произойдет.</i></b></p>

    <pre class="brush: js;">
        var foo = (function CoolModule(id) {

            function change() {
                // изменение открытого API
                publicAPI.identify = identify2;
            }

            function identify1() {
                console.log( id );
            }

            function identify2() {
                console.log( id.toUpperCase() );
            }

            var publicAPI = {
                change: change,
                identify: identify1
            };

            return publicAPI;

        })( "foo module" );

        foo.identify(); // foo module
        foo.change();
        foo.identify(); // FOO MODULE
    </pre>

    <p><b>Современные модули</b></p>

    <pre class="brush: js;">
        // определения нескольких модулей
        MyModules.define( "bar", [], function(){
            function hello(who) {
                return "Let me introduce: " + who;
            }
            return {
                hello: hello
            };
        } );

        MyModules.define( "foo", ["bar"], function(bar){
            var hungry = "hippo";
            function awesome() {
                console.log( bar.hello( hungry ).toUpperCase() );
            }
            return {
                awesome: awesome
            };
        } );

        var bar = MyModules.get( "bar" );
        var foo = MyModules.get( "foo" );

        console.log(
            bar.hello( "hippo" )
        ); // Let me introduce: hippo

        foo.awesome(); // LET ME INTRODUCE: HIPPO
    </pre>

</div>

<!--
<pre class="brush: js;">

</pre>

<div class="linear" id="chapter5">

    <h2>Глава 5: </h2>


</div>

<ul class="ul_num">
    <li></li>
</ul>
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
