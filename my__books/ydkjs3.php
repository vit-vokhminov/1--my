<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: Что такое this?</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: this обретает смысл!</a></li>
        <li><a class="list-sub__link" href="#chapter3">Глава 3: Объекты</a></li>
    </ul>
</div>



<div class="linear" id="chapter1">

    <h2>Глава 1: Что такое this?</h2>

    <p>Cвязывание <code>this</code> осуществляется не во
        время написания программы, а во время выполнения. Связывание
        является контекстным, то есть базируется на условиях вызова
        функции. Связывание <code>this</code> не имеет никакого отношения к тому,
        где была объявлена функция, но <b><i>полностью определяется способом вызова этой функции</i></b>.</p>

    <p>При вызове функции создается запись активации, также называемая контекстом выполнения. Запись содержит информацию
        о том, откуда была вызвана функция (стек вызовов), как она была
        вызвана, какие параметры были переданы при вызове и т. д. Одним
        из свойств этой записи является ссылка <code>this</code>, которая используется на протяжении выполнения этой функции.</p>

    <p>Связывание <code>this</code> происходит в момент вызова функции, и то, на
        что ссылается <code>this</code>, <b><i>определяется исключительно местом вызова,
                из которого была вызвана функция (то есть способа вызова функции)</i></b>.</p>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: this обретает смысл!</h2>

    <p><b>Место вызова</b></p>

    <p>Чтобы понять связывание, необходимо понять концепцию <code>места
            вызова (call-site)</code>: позицию кода, в которой вызывается функция
        (а не ту, где она была объявлена). Необходимо проанализировать
        место вызова, чтобы ответить на вопрос: на что указывает ссылка <code>this</code>?</p>

    <pre class="brush: js;">
        function baz() {
            // Стек вызовов: `baz`
            // Следовательно, место вызова принадлежит глобальной области видимости
            console.log( "baz" );
            bar(); // <-- Место вызова для `bar`
        }

        function bar() {
            // Стек вызовов: `baz` -> `bar`
            // Следовательно, место вызова находится в `baz`
            console.log( "bar" );
            foo(); // <-- Место вызова для `foo`
        }

        function foo() {
            // Стек вызовов: `baz` -> `bar` -> `foo`
            // Следовательно, место вызова находится в `bar`
            console.log( "foo" );
        }

        baz(); // <-- Место вызова для `baz`
    </pre>

    <br>
    <br>

    <p><b>4 правила определения контекста this</b></p>

    <ul class="ul_num">
        <li>Связывание по умолчанию</li>
        <li>Неявное связывание</li>
        <li>Неявная потеря this</li>
        <li>Связывание new</li>
    </ul>

    <br>

    <p><b>Первое правило: <i>Связывание по умолчанию</i></b></p>

    <p>Первое правило, происходит от самого распространенного случая вызовов функций: автономных
        вызовов функций. Считайте, что это правило будет использовано
        по умолчанию, если не применяется ни одно из других правил.</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var a = 2;
        foo();      // 2
    </pre>

    <p>Cвязывание по умолчанию <code>this</code> применяется к вызову функции, а следовательно, <code>this</code> указывает на глобальный объект.</p>

    <p>Если действует режим <code>strict</code>, глобальный объект не может использоваться для связывания по умолчанию, поэтому <code>this</code> вместо
        этого присваивается <code>undefined</code>:</p>

    <pre class="brush: js;">
        function foo() {
            "use strict";
            console.log( this.a );
        }

        var a = 2;
        foo();      // TypeError: `this` is `undefined`
    </pre>

    <p>Хотя в целом эти правила связывания полностью зависят от места вызова, глобальный объект
        доступен для связывания по умолчанию только в том случае, если
        содержимое <code>foo()</code> не выполняется в режиме <code>strict</code>; действие режима <code>strict</code> для места вызова <code>foo()</code> роли не играет:</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var a = 2;

        (function(){
            "use strict";
            foo();      // 2
        })();
    </pre>

    <br>

    <p><b>Второе правило: <i>Неявное связывание</i></b></p>

    <p>Другое правило, которое необходимо учитывать, — наличие у места вызова контекстного объекта, также называемого владельцем
        (<code>owner</code>) или содержащим объектом</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        obj.foo(); // 2
    </pre>

    <p>В точке
        вызова <code>foo()</code> имени функции будет предшествовать ссылка на
        объект <code>obj</code>. Когда при обращении к функции указывается контекстный объект, правило неявного связывания требует, чтобы
        этот объект использовался для связывания <code>this</code> данного вызова
        функции. Поскольку <code>obj</code> становится <code>this</code> для вызова <code>foo()</code>, синтаксис <code>this.a</code> является синонимом <code>obj.a</code>.</p>

    <p>На случай, если у объекта будет много прототипов. Для места вызова важен только верхний/последний уровень цепочки ссылок на свойства объекта.</p>

    <br>

    <p><b>Третье правило: <i>Неявная потеря this</i></b></p>

    <p>Одна из самых распространенных проблем, возникающих при
        связывании, — когда функция с неявным связыванием теряет это
        связывание, что обычно означает возврат к связыванию по умолчанию — глобальному объекту или <code>undefined</code> в зависимости от
        действия режима <code>strict</code></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        var bar = obj.foo;       // Ссылка на функцию/синоним!
        var a = "oops, global";         // `a` также является свойством глобального объекта

        bar();      // "oops, global"
    </pre>

    <p>И хотя <code>bar</code> кажется ссылкой на <code>obj.foo</code>, в действительности это
        всего лишь еще одна ссылка на саму функцию <code>foo</code>. Кроме того,
        важно только место вызова, а здесь оно имеет вид <code>bar()</code> — простой
        вызов без префикса, а следовательно, здесь применяется связывание по умолчанию.</p>

    <p>Более тонкий, более распространенный и более неожиданный
        пример встречается при передаче функции обратного вызова:</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        function doFoo(fn) {
            // `fn` - просто еще одна ссылка на `foo`
            fn();       // <-- место вызова!
        }

        var obj = {
            a: 2,
            foo: foo
        };

        var a = "oops, global";         // `a` также является свойством глобального объекта

        doFoo( obj.foo );       // "oops, global"
    </pre>

    <p><b>Явное связывание</b> <code>call()</code></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2
        };

        foo.call( obj ); // 2
    </pre>

    <p>Вызов <code>foo</code> с явным связыванием <code>foo.call(..)</code> позволяет принудительно задать его <code>this</code> значение <code>obj</code></p>

    <p><b>Жесткое связывание</b></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2
        };

        var bar = function() {
            foo.call( obj );
        };

        bar();      // 2
        setTimeout( bar, 100 );         // 2
        // У жестко связанной функции `bar` значение `this` не может заменяться
        bar.call( window );         // 2
    </pre>

    <p>Мы создаем
        функцию <code>bar()</code>, которая во внутренней реализации вручную
        вызывает <code>foo.call(obj)</code>, принудительно вызывая <code>foo</code> со связыванием <code>obj</code> для <code>this</code>. Неважно, как позднее будет вызываться
        функция <code>bar</code> — она всегда вручную будет вызывать <code>foo</code> c <code>obj</code>.
        Такой способ связывания явно выражен и надежен; мы будем
        называть его жестким связыванием.</p>

    <pre class="brush: js;">
        function foo(something) {
            console.log( this.a, something );
            return this.a + something;
        }

        var obj = {
            a: 2
        };

        var bar = function() {
            return foo.apply( obj, arguments );
        };

        var b = bar( 3 ); // 2 3
        console.log( b ); // 5
    </pre>

    <p><code>bind()</code></p>

    <pre class="brush: js;">
        function foo(something) {
            console.log( this.a, something );
            return this.a + something;
        }

        var obj = {
            a: 2
        };

        var bar = foo.bind( obj );
        var b = bar( 3 ); // 2 3
        console.log( b ); // 5
    </pre>

    <p><code>bind(..)</code> возвращает новую функцию, жестко запрограмированную для вызова исходной функции с заданным вами контекстом <code>this</code></p>

    <br>

    <p><b>«Контексты» вызовов API</b></p>

    <p>Функции многих библиотек, а также многие новые встроенные
        функции языка JavaScript и управляющей среды поддерживают
        необязательный параметр (обычно с именем <code>context</code>), который
        избавляет вас от необходимости использовать <code>bind()</code>, чтобы ваша
        функция обратного вызова гарантированно использовала конкретное значение <code>this</code></p>

    <pre class="brush: js;">
        function foo(el) {
            console.log( el, this.id );
        }

        var obj = {
            id: "awesome"
        };

        // Использовать `obj` как `this` для вызовов `foo(..)`
        [1, 2, 3].forEach( foo, obj );
        // 1 awesome 2 awesome 3 awesome
    </pre>

    <p>Во внутренней реализации эти функции почти наверняка используют явное связывание вызовом <code>call(..)</code> или <code>apply(..)</code>, избавляя
        вас от лишних хлопот</p>

    <br>

    <p><b>Четвёртое правило: <i>Связывание new</i></b></p>

    <p>Когда функция вызывается после оператора <code>new</code> (такие вызовы называются <b><i>вызовами-конструкторами</i></b>), автоматически выполняются следующие действия:</p>

    <ul class="ul_num">
        <li>Создается (конструируется) новый объект.</li>
        <li>Производится связывание сконструированного объекта с <code>[[Prototype]]</code>.</li>
        <li>Сконструированный объект назначается в качестве связывания <code>this</code> для этого вызова функции.</li>
        <li>Если функция не возвращает свой альтернативный объект, вызов функции автоматически возвращает сконструированный объект</li>
    </ul>

    <pre class="brush: js;">
        function foo(a) {
            this.a = a;
        }

        var bar = new foo( 2 );
        console.log( bar.a ); // 2
    </pre>

    <p>Вызывая <code>foo(..)</code> после <code>new</code>, мы конструируем новый объект и назначаем его в качестве значения <code>this</code> для вызова <code>foo(..)</code>. Итак,
        <code>new</code> — последний способ связывания <code>this</code> для вызова функции.
        Назовем его связыванием <code>new</code></p>

    <br>

    <p><b>Приоритет правил определения контекста this</b></p>

    <ul class="ul_num">
        <li>Связывание new</li>
        <li>Явное связывание</li>
        <li>Неявное связывание</li>
        <li>Привязка по умолчанию</li>
    </ul>

    <p><b>Определение this</b></p>

    <ul class="ul_num">
        <li>Функция вызвана с <code>new</code> (связывание <code>new</code>)? Если да, то <code>this</code> содержит новый сконструированный объект.
            <code>var bar = new foo()</code></li>
        <li>Функция вызвана с <code>call</code> или <code>apply</code> (явное связывание), даже
            скрытыми в жесткой привязке <code>bind</code>? Если да, то <code>this</code> содержит
            явно заданный объект.
            <code>var bar = foo.call( obj2 )</code></li>
        <li>Функция вызвана с контекстом (неявное связывание), также
            называемым объектом-владельцем или содержащим объектом?
            Если да, то <code>this</code> содержит контекстный объект.
            <code>var bar = obj1.foo()</code></li>
        <li>В остальных случаях используется <code>this</code> по умолчанию (привязка по умолчанию). Если действует режим <code>strict</code>, выбирается <code>undefined</code>, а если нет — глобальный объект:
            <code>var bar = foo()</code></li>
    </ul>


</div>

<div class="linear" id="chapter3">

    <h2>Глава 3: Объекты</h2>

    <p>Объекты в JS могут определяться в литеральной форме (например,
        <code>var a = { .. })</code> и в сконструированной форме (например, <code>var a =
            new Array(..))</code>. Литеральная форма почти всегда предпочтительна, но сконструированная форма в некоторых случаях предоставляет больше возможностей для создания объектов.</p>
    <p>Многие люди ошибочно утверждают, что «в JavaScript нет ничего,
        кроме объектов», но это не так. Объекты — один из шести (или
        семи в зависимости от точки зрения) примитивных типов. У объектов есть подтипы (например, <code>function</code>), и они могут обладать
        специализированным поведением, например, <code>[object Array]</code> как
        внутренняя метка, представляющая подтип объекта-массива.</p>
    <p>Объекты представляют собой коллекции пар <b><i>«ключ/значение»</i></b>.
        К значениям можно обращаться как к свойствам в синтаксисе
        <code>.propName</code> или <code>["propName"]</code>. При каждом обращении к свойству
        движок вызывает внутреннюю операцию <code>[[Get]]</code> по умолчанию
        (<code>[[Put]]</code> для присваивания значений), которая не только ищет
        свойство непосредственно в объекте, но и обходит цепочку
        <code>[[Prototype]]</code>, если свойство не было найдено.</p>
    <p>Свойства обладают некоторыми характеристиками, которыми
        можно управлять при помощи дескрипторов свойств (например,
        <code>writable</code> и <code>configurable</code>). Кроме того, возможностью изменения
        объектов (и их свойств) можно управлять на разных уровнях при
        помощи <code>Object.preventExtensions(..)</code>, <code>Object.seal(..)</code> и <code>Object.
            freeze(..)</code>.</p>
    <p>Свойства не обязательно содержат значения — они также могут
        быть <b><i>«свойствами доступа»</i></b> с геттерами/сеттерами. Также свойства могут быть или не быть перечисляемыми; например, эта
        характеристика управляет тем, будут ли они включаться в перебор в цикле <code>for..in</code>.</p>
    <p>Также возможен перебор значений в структурах данных (массивы,
        объекты и т. д.) с использованием синтаксиса ES6 <code>for..of</code>. Для
        него необходим либо встроенный, либо пользовательский объект
        <code>@@iterator</code>, содержащий метод <code>next()</code> для последовательного перехода между значениями данных/</p>

</div>


<!--
<pre class="brush: js;">

</pre>

<div class="linear" id="chapter5">

    <h2>Глава 5: </h2>


</div>

<ul class="ul_num">
    <li></li>
</ul>
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
