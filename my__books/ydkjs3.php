<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: Что такое this?</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: this обретает смысл!</a></li>
        <li><a class="list-sub__link" href="#chapter3">Глава 3: Объекты</a></li>
        <li><a class="list-sub__link" href="#chapter4">Глава 4: Классы</a></li>
        <li><a class="list-sub__link" href="#chapter5">Глава 5: Прототипы</a></li>
        <li><a class="list-sub__link" href="#chapter6">Глава 6: Делегирование поведения</a></li>
    </ul>
</div>



<div class="linear" id="chapter1">

    <h2>Глава 1: Что такое this?</h2>

    <p>Cвязывание <code>this</code> осуществляется не во
        время написания программы, а во время выполнения. Связывание
        является контекстным, то есть базируется на условиях вызова
        функции. Связывание <code>this</code> не имеет никакого отношения к тому,
        где была объявлена функция, но <b><i>полностью определяется способом вызова этой функции</i></b>.</p>

    <p>При вызове функции создается запись активации, также называемая контекстом выполнения. Запись содержит информацию
        о том, откуда была вызвана функция (стек вызовов), как она была
        вызвана, какие параметры были переданы при вызове и т. д. Одним
        из свойств этой записи является ссылка <code>this</code>, которая используется на протяжении выполнения этой функции.</p>

    <p>Связывание <code>this</code> происходит в момент вызова функции, и то, на
        что ссылается <code>this</code>, <b><i>определяется исключительно местом вызова,
                из которого была вызвана функция (то есть способа вызова функции)</i></b>.</p>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: this обретает смысл!</h2>

    <p><b>Место вызова</b></p>

    <p>Чтобы понять связывание, необходимо понять концепцию <code>места
            вызова (call-site)</code>: позицию кода, в которой вызывается функция
        (а не ту, где она была объявлена). Необходимо проанализировать
        место вызова, чтобы ответить на вопрос: на что указывает ссылка <code>this</code>?</p>

    <pre class="brush: js;">
        function baz() {
            // Стек вызовов: `baz`
            // Следовательно, место вызова принадлежит глобальной области видимости
            console.log( "baz" );
            bar(); // <-- Место вызова для `bar`
        }

        function bar() {
            // Стек вызовов: `baz` -> `bar`
            // Следовательно, место вызова находится в `baz`
            console.log( "bar" );
            foo(); // <-- Место вызова для `foo`
        }

        function foo() {
            // Стек вызовов: `baz` -> `bar` -> `foo`
            // Следовательно, место вызова находится в `bar`
            console.log( "foo" );
        }

        baz(); // <-- Место вызова для `baz`
    </pre>

    <br>
    <br>

    <p><b>4 правила определения контекста this</b></p>

    <ul class="ul_num">
        <li>Связывание по умолчанию</li>
        <li>Неявное связывание</li>
        <li>Неявная потеря this</li>
        <li>Связывание new</li>
    </ul>

    <br>

    <p><b>Первое правило: <i>Связывание по умолчанию</i></b></p>

    <p>Первое правило, происходит от самого распространенного случая вызовов функций: автономных
        вызовов функций. Считайте, что это правило будет использовано
        по умолчанию, если не применяется ни одно из других правил.</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var a = 2;
        foo();      // 2
    </pre>

    <p>Cвязывание по умолчанию <code>this</code> применяется к вызову функции, а следовательно, <code>this</code> указывает на глобальный объект.</p>

    <p>Если действует режим <code>strict</code>, глобальный объект не может использоваться для связывания по умолчанию, поэтому <code>this</code> вместо
        этого присваивается <code>undefined</code>:</p>

    <pre class="brush: js;">
        function foo() {
            "use strict";
            console.log( this.a );
        }

        var a = 2;
        foo();      // TypeError: `this` is `undefined`
    </pre>

    <p>Хотя в целом эти правила связывания полностью зависят от места вызова, глобальный объект
        доступен для связывания по умолчанию только в том случае, если
        содержимое <code>foo()</code> не выполняется в режиме <code>strict</code>; действие режима <code>strict</code> для места вызова <code>foo()</code> роли не играет:</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var a = 2;

        (function(){
            "use strict";
            foo();      // 2
        })();
    </pre>

    <br>

    <p><b>Второе правило: <i>Неявное связывание</i></b></p>

    <p>Другое правило, которое необходимо учитывать, — наличие у места вызова контекстного объекта, также называемого владельцем
        (<code>owner</code>) или содержащим объектом</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        obj.foo(); // 2
    </pre>

    <p>В точке
        вызова <code>foo()</code> имени функции будет предшествовать ссылка на
        объект <code>obj</code>. Когда при обращении к функции указывается контекстный объект, правило неявного связывания требует, чтобы
        этот объект использовался для связывания <code>this</code> данного вызова
        функции. Поскольку <code>obj</code> становится <code>this</code> для вызова <code>foo()</code>, синтаксис <code>this.a</code> является синонимом <code>obj.a</code>.</p>

    <p>На случай, если у объекта будет много прототипов. Для места вызова важен только верхний/последний уровень цепочки ссылок на свойства объекта.</p>

    <br>

    <p><b>Третье правило: <i>Неявная потеря this</i></b></p>

    <p>Одна из самых распространенных проблем, возникающих при
        связывании, — когда функция с неявным связыванием теряет это
        связывание, что обычно означает возврат к связыванию по умолчанию — глобальному объекту или <code>undefined</code> в зависимости от
        действия режима <code>strict</code></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        var bar = obj.foo;       // Ссылка на функцию/синоним!
        var a = "oops, global";         // `a` также является свойством глобального объекта

        bar();      // "oops, global"
    </pre>

    <p>И хотя <code>bar</code> кажется ссылкой на <code>obj.foo</code>, в действительности это
        всего лишь еще одна ссылка на саму функцию <code>foo</code>. Кроме того,
        важно только место вызова, а здесь оно имеет вид <code>bar()</code> — простой
        вызов без префикса, а следовательно, здесь применяется связывание по умолчанию.</p>

    <p>Более тонкий, более распространенный и более неожиданный
        пример встречается при передаче функции обратного вызова:</p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        function doFoo(fn) {
            // `fn` - просто еще одна ссылка на `foo`
            fn();       // <-- место вызова!
        }

        var obj = {
            a: 2,
            foo: foo
        };

        var a = "oops, global";         // `a` также является свойством глобального объекта

        doFoo( obj.foo );       // "oops, global"
    </pre>

    <p><b>Явное связывание</b> <code>call()</code></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2
        };

        foo.call( obj ); // 2
    </pre>

    <p>Вызов <code>foo</code> с явным связыванием <code>foo.call(..)</code> позволяет принудительно задать его <code>this</code> значение <code>obj</code></p>

    <p><b>Жесткое связывание</b></p>

    <pre class="brush: js;">
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2
        };

        var bar = function() {
            foo.call( obj );
        };

        bar();      // 2
        setTimeout( bar, 100 );         // 2
        // У жестко связанной функции `bar` значение `this` не может заменяться
        bar.call( window );         // 2
    </pre>

    <p>Мы создаем
        функцию <code>bar()</code>, которая во внутренней реализации вручную
        вызывает <code>foo.call(obj)</code>, принудительно вызывая <code>foo</code> со связыванием <code>obj</code> для <code>this</code>. Неважно, как позднее будет вызываться
        функция <code>bar</code> — она всегда вручную будет вызывать <code>foo</code> c <code>obj</code>.
        Такой способ связывания явно выражен и надежен; мы будем
        называть его жестким связыванием.</p>

    <pre class="brush: js;">
        function foo(something) {
            console.log( this.a, something );
            return this.a + something;
        }

        var obj = {
            a: 2
        };

        var bar = function() {
            return foo.apply( obj, arguments );
        };

        var b = bar( 3 ); // 2 3
        console.log( b ); // 5
    </pre>

    <p><code>bind()</code></p>

    <pre class="brush: js;">
        function foo(something) {
            console.log( this.a, something );
            return this.a + something;
        }

        var obj = {
            a: 2
        };

        var bar = foo.bind( obj );
        var b = bar( 3 ); // 2 3
        console.log( b ); // 5
    </pre>

    <p><code>bind(..)</code> возвращает новую функцию, жестко запрограмированную для вызова исходной функции с заданным вами контекстом <code>this</code></p>

    <br>

    <p><b>«Контексты» вызовов API</b></p>

    <p>Функции многих библиотек, а также многие новые встроенные
        функции языка JavaScript и управляющей среды поддерживают
        необязательный параметр (обычно с именем <code>context</code>), который
        избавляет вас от необходимости использовать <code>bind()</code>, чтобы ваша
        функция обратного вызова гарантированно использовала конкретное значение <code>this</code></p>

    <pre class="brush: js;">
        function foo(el) {
            console.log( el, this.id );
        }

        var obj = {
            id: "awesome"
        };

        // Использовать `obj` как `this` для вызовов `foo(..)`
        [1, 2, 3].forEach( foo, obj );
        // 1 awesome 2 awesome 3 awesome
    </pre>

    <p>Во внутренней реализации эти функции почти наверняка используют явное связывание вызовом <code>call(..)</code> или <code>apply(..)</code>, избавляя
        вас от лишних хлопот</p>

    <br>

    <p><b>Четвёртое правило: <i>Связывание new</i></b></p>

    <p>Когда функция вызывается после оператора <code>new</code> (такие вызовы называются <b><i>вызовами-конструкторами</i></b>), автоматически выполняются следующие действия:</p>

    <ul class="ul_num">
        <li>Создается (конструируется) новый объект.</li>
        <li>Производится связывание сконструированного объекта с <code>[[Prototype]]</code>.</li>
        <li>Сконструированный объект назначается в качестве связывания <code>this</code> для этого вызова функции.</li>
        <li>Если функция не возвращает свой альтернативный объект, вызов функции автоматически возвращает сконструированный объект</li>
    </ul>

    <pre class="brush: js;">
        function foo(a) {
            this.a = a;
        }

        var bar = new foo( 2 );
        console.log( bar.a ); // 2
    </pre>

    <p>Вызывая <code>foo(..)</code> после <code>new</code>, мы конструируем новый объект и назначаем его в качестве значения <code>this</code> для вызова <code>foo(..)</code>. Итак,
        <code>new</code> — последний способ связывания <code>this</code> для вызова функции.
        Назовем его связыванием <code>new</code></p>

    <br>

    <p><b>Приоритет правил определения контекста this</b></p>

    <ul class="ul_num">
        <li>Связывание new</li>
        <li>Явное связывание</li>
        <li>Неявное связывание</li>
        <li>Привязка по умолчанию</li>
    </ul>

    <p><b>Определение this</b></p>

    <ul class="ul_num">
        <li>Функция вызвана с <code>new</code> (связывание <code>new</code>)? Если да, то <code>this</code> содержит новый сконструированный объект.
            <code>var bar = new foo()</code></li>
        <li>Функция вызвана с <code>call</code> или <code>apply</code> (явное связывание), даже
            скрытыми в жесткой привязке <code>bind</code>? Если да, то <code>this</code> содержит
            явно заданный объект.
            <code>var bar = foo.call( obj2 )</code></li>
        <li>Функция вызвана с контекстом (неявное связывание), также
            называемым объектом-владельцем или содержащим объектом?
            Если да, то <code>this</code> содержит контекстный объект.
            <code>var bar = obj1.foo()</code></li>
        <li>В остальных случаях используется <code>this</code> по умолчанию (привязка по умолчанию). Если действует режим <code>strict</code>, выбирается <code>undefined</code>, а если нет — глобальный объект:
            <code>var bar = foo()</code></li>
    </ul>


</div>

<div class="linear" id="chapter3">

    <h2>Глава 3: Объекты</h2>

    <p>Объекты в JS могут определяться в литеральной форме (например,
        <code>var a = { .. })</code> и в сконструированной форме (например, <code>var a =
            new Array(..))</code>. Литеральная форма почти всегда предпочтительна, но сконструированная форма в некоторых случаях предоставляет больше возможностей для создания объектов.</p>
    <p>Многие люди ошибочно утверждают, что «в JavaScript нет ничего,
        кроме объектов», но это не так. Объекты — один из шести (или
        семи в зависимости от точки зрения) примитивных типов. У объектов есть подтипы (например, <code>function</code>), и они могут обладать
        специализированным поведением, например, <code>[object Array]</code> как
        внутренняя метка, представляющая подтип объекта-массива.</p>
    <p>Объекты представляют собой коллекции пар <b><i>«ключ/значение»</i></b>.
        К значениям можно обращаться как к свойствам в синтаксисе
        <code>.propName</code> или <code>["propName"]</code>. При каждом обращении к свойству
        движок вызывает внутреннюю операцию <code>[[Get]]</code> по умолчанию
        (<code>[[Put]]</code> для присваивания значений), которая не только ищет
        свойство непосредственно в объекте, но и обходит цепочку
        <code>[[Prototype]]</code>, если свойство не было найдено.</p>
    <p>Свойства обладают некоторыми характеристиками, которыми
        можно управлять при помощи дескрипторов свойств (например,
        <code>writable</code> и <code>configurable</code>). Кроме того, возможностью изменения
        объектов (и их свойств) можно управлять на разных уровнях при
        помощи <code>Object.preventExtensions(..)</code>, <code>Object.seal(..)</code> и <code>Object.
            freeze(..)</code>.</p>
    <p>Свойства не обязательно содержат значения — они также могут
        быть <b><i>«свойствами доступа»</i></b> с геттерами/сеттерами. Также свойства могут быть или не быть перечисляемыми; например, эта
        характеристика управляет тем, будут ли они включаться в перебор в цикле <code>for..in</code>.</p>
    <p>Также возможен перебор значений в структурах данных (массивы,
        объекты и т. д.) с использованием синтаксиса ES6 <code>for..of</code>. Для
        него необходим либо встроенный, либо пользовательский объект
        <code>@@iterator</code>, содержащий метод <code>next()</code> для последовательного перехода между значениями данных/</p>

</div>

<div class="linear" id="chapter4">

    <h2>Глава 4: Классы</h2>

    <p>Классы являются паттерном проектирования. Многие языки
        предоставляют синтаксис, который делает возможным естественное проектирование программного кода, ориентированное на
        использование классов. В JS также имеется похожий синтаксис,
        но по своему поведению он сильно отличается от того, к чему вы
        привыкли с классами из других языков.</p>

    <p>Классы подразумевают копирование.</p>

    <p>При создании экземпляра традиционных классов происходит
        копирование поведения из класса в экземпляр. При наследовании
        классов также происходит копирование поведения из родителя
        в потомка.</p>

    <p>Может показаться, что полиморфизм (существование разных
        функций с одинаковыми именами на разных уровнях цепочки
        наследования) подразумевает наличие относительной связи по
        ссылке от потомка к родителю, но в действительности он всего
        лишь является результатом копирования.</p>

    <p>JavaScript не использует автоматическое копирование (как обычно подразумевают классы) между объектами.</p>

    <p>Паттерн «примесь» (явный и неявный) часто используется для
        моделирования поведения копирования классов, но обычно он
        ведет к уродливому и ненадежному синтаксису, например явному
        псевдополиморфизму (<code>OtherObj.methodName.call(this, ...)</code>), что
        часто приводит к созданию кода, более сложного для понимания
        и сопровождения.</p>

    <p> Явные примеси тоже не совсем точно воспроизводят поведение
        копирования классов, так как для объектов (и функций) копируются только общие ссылки, а не сами объекты/функции. На такие
        нюансы необходимо обращать внимание, иначе они станут источником всевозможных проблем.</p>

    <p>В целом имитация классов в JS обычно готовит больше скрытых
        ловушек в будущем, чем решает реальных проблем в настоящем.</p>

</div>

<div class="linear" id="chapter5">

    <h2>Глава 5: Прототипы</h2>

    <p>При попытке обращения к свойству для объекта, у которого это
        свойство отсутствует, внутренняя связь [<code>[Prototype]</code>] объекта
        определяет, где операция [[<code>Get</code>]] (см. главу 8) должна продолжить
        поиск. Система каскадных ссылок между объектами фактически
        определяет «цепочку прототипов» (нечто вроде иерархической
        цепочки областей видимости) объектов, которые должны перебираться при разрешении свойств.</p>

    <p>У всех нормальных объектов на вершине цепочки прототипов
        находится встроенный объект <code>Object.prototype</code> (аналог глобальной области видимости при поиске в областях видимости), на
        котором останавливается разрешение свойств, не найденных
        в предыдущих звеньях цепочки. Объект <code>Object.prototype</code> содержит
        <code>toString()</code>, <code>valueOf()</code> и ряд других общих функций; это объясняет,
        почему они доступны для всех объектов в языке.</p>

    <p>Самый распространенный способ связывания двух объектов —
        использование ключевого слова new с вызовом функции. В результате во время четырех фаз выполнения (см. главу 9) создается
        новый объект, связанный с другим объектом.</p>

    <p>«Другим объектом», с которым связывается новый объект, становится объект, на который указывает свойство с (неудачным)
        именем <code>.prototype</code> функции, вызываемой с <code>new</code>. Функции, вызываемые с new, часто называются «конструкторами», хотя они
        и не пытаются создавать экземпляры классов, как это делают
        конструкторы в традиционных языках, ориентированных на
        использование классов.</p>

    <p>Хотя эти механизмы JavaScript на первый взгляд напоминают
        «создание экземпляров» и «наследование классов» из традиционных языков, ориентированных на использование классов,
        ключевое различие заключается в том, что в JavaScript копирование не производится. Вместо этого объекты связываются друг
        с другом по внутренней цепочке [<code>[Prototype]</code>].</p>

    <p>По разнообразным причинам, в том числе из-за распространенной
        терминологии, «наследование» (и «наследование на основе прототипов»), а также все остальные ОО-термины просто не подходят
        для описания того, как реально работают механизмы JavaScript
        (а не только применительно к нашим моделям мышления).</p>

    <p>Правильнее здесь было бы использовать термин «делегирование»,
        потому что отношения представляются не копиями, а связями
        делегирования.</p>

</div>

<div class="linear" id="chapter6">

    <h2>Глава 6: Делегирование поведения</h2>

    <p>Механизм [<code>[Prototype]</code>] основан на внутренней ссылке, которая существует в одном объекте и указывает на другой объект.</p>

    <p>Эта связь используется в том случае, если программа обращается
        к свойству/методу первого объекта, но такое свойство/метод не
        существует. В этом случае связь [<code>[Prototype]</code>] сообщает движку,
        что поиск свойства/метода следует продолжить в связанном объекте. В свою очередь, если этот объект не может удовлетворить
        запрос, происходит переход по его ссылке [<code>[Prototype]</code>] и т. д. Эта
        серия ссылок между объектами образует так называемую «цепочку прототипов».</p>

    <p>Иначе говоря, вся суть механизма, все то, что важно для функциональности, которая может использоваться в JavaScript, <b><i>заключается в связях одних объектов с другими объектами</i></b>.</p>


    <table class="table_pre">
        <tr>
            <td>Классы</td>
            <td>Делегирование поведения</td>
        </tr>
        <tr>
            <td>
                <pre class="brush: js;">
                    class Widget {
                        constructor(width,height) {
                            this.width = width || 50;
                            this.height = height || 50;
                            this.$elem = null;
                        }
                        render($where){
                            if (this.$elem) {
                                this.$elem.css( {
                                    width: this.width + "px",
                                    height: this.height + "px"
                                } ).appendTo( $where );
                            }
                        }
                    }

                    class Button extends Widget {
                        constructor(width,height,label) {
                            super( width, height );
                            this.label = label || "Default";
                            this.$elem = $( "<button>" ).text( this.label );
                        }
                        render($where) {
                            super( $where );
                            this.$elem.click( this.onClick.bind( this ) );
                        }
                        onClick(evt) {
                            console.log( "Button ‘" + this.label + "’ clicked!" );
                        }
                    }

                    $( document ).ready( function(){
                        var $body = $( document.body );
                        var btn1 = new Button( 125, 30, "Hello" );
                        var btn2 = new Button( 150, 40, "World" );

                        btn1.render( $body );
                        btn2.render( $body );
                    } );
                </pre>
            </td>
            <td>
                <pre class="brush: js;">
                    var Widget = {
                        init: function(width,height){
                            this.width = width || 50;
                            this.height = height || 50;
                            this.$elem = null;
                        },
                        insert: function($where){
                            if (this.$elem) {
                                this.$elem.css( {
                                    width: this.width + "px",
                                    height: this.height + "px"
                                } ).appendTo( $where );
                            }
                        }
                    };

                    var Button = Object.create( Widget );

                    Button.setup = function(width,height,label){
                        // делегированный вызов
                        this.init( width, height );
                        this.label = label || "Default";
                        this.$elem = $( "<button>" ).text( this.label );
                    };

                    Button.build = function($where) {
                        // делегированный вызов
                        this.insert( $where );
                        this.$elem.click( this.onClick.bind( this ) );
                    };

                    Button.onClick = function(evt) {
                        console.log( "Button '" + this.label + "' clicked!" );
                    };

                    $( document ).ready( function(){
                        var $body = $( document.body );

                        var btn1 = Object.create( Button );
                        btn1.setup( 125, 30, "Hello" );

                        var btn2 = Object.create( Button );
                        btn2.setup( 150, 40, "World" );

                        btn1.build( $body );
                        btn2.build( $body );
                    } );
                </pre>
            </td>
        </tr>
    </table>

    <br>

    <p>В отличие от программирования, ориентированного на использование классов (то есть объектно-ориентированного), я называю
        такой стиль программирования <code>OLOO (Objects Linked to Other
            Objects</code>, то есть «объекты, связанные с другими объектами»). На
        самом деле нас интересует лишь то, что объект XYZ делегирует обращения объекту Task (как и объект ABC).</p>

    <p><b><i><code>OLOO</code> лучше поддерживает принцип разделения обязанностей,
                согласно которому создание и инициализация не обязательно
                объединены в одну операцию.</i></b></p>

    <p>Классы и наследование — паттерн проектирования, который вы
        можете выбрать или не выбрать в архитектуре своего программного продукта. Многие разработчики беспрекословно считают,
        что классы являются единственным (правильным) способом
        организации кода, но в этой главе было показано, что существует
        другой, очень мощный, но реже обсуждаемый паттерн: делегирование поведения.</p>

    <p>Делегирование поведения предполагает, что объекты находятся
        на одном уровне иерархии и делегируют поведение друг другу
        (в отличие от отношений «родитель/потомок», типичных для
        классов). Механизм [<code>[Prototype]</code>] в JavaScript по самой своей
        природе является механизмом делегирования поведения. Это
        означает, что вы можете либо прикладывать усилия, чтобы реализовать механику классов поверх JS (см. главы 9 и 10), либо
        просто принять естественное состояние [<code>[Prototype]</code>] как механизм делегирования.</p>

    <p>Проектирование кода только с одними объектами не только упрощает синтаксис, но и приводит к более простой архитектуре кода.</p>

    <p><code>OLOO (Objects Linked to Other Objects)</code> — стиль программирования, при котором объекты создаются и связываются напрямую
        без участия абстракции классов. <code>OLOO</code> вполне естественно реализует делегирование поведения на базе [<code>[Prototype]</code>].</p>

</div>

<!--
<pre class="brush: js;">

</pre>

<div class="linear" id="chapter5">

    <h2>Глава 5: </h2>


</div>

<ul class="ul_num">
    <li></li>
</ul>
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
