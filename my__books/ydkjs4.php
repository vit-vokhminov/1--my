<?php include $_SERVER['DOCUMENT_ROOT'].'/include/header.php'; ?>



<div class="nav_bar">
    <br>
    <p><i>Содержание:</i></p>
    <ul>
        <li><a class="list-sub__link" href="#chapter1">Глава 1: Типы</a></li>
        <li><a class="list-sub__link" href="#chapter2">Глава 2: Значения</a></li>
        <li><a class="list-sub__link" href="#chapter3">Глава 3: Встроенные объекты (natives)</a></li>
        <li><a class="list-sub__link" href="#chapter4">Глава 4: Преобразование типов</a></li>
        <li><a class="list-sub__link" href="#chapter5">Глава 5: Грамматика</a></li>
    </ul>
</div>



<div class="linear" id="chapter1">

    <h2>Глава 1: Типы</h2>

    <p>В JavaScript есть семь встроенных типов: <code>null</code>, <code>undefined</code>, <code>boolean</code>,
        <code>number</code>, <code>string</code>, <code>object</code> и <code>symbol</code>. Тип значений можно идентифицировать оператором <code>typeof</code>.</p>

    <p>Переменные не имеют типов, но зато типы есть у хранящихся
        в них значений. Типы определяют поведение, присущее этим
        значениям.</p>

    <p>Многие разработчики считают, что <b><i>«не определено»</i></b> (<code>undefined</code>)
        и <b><i>«не объявлено»</i></b> — приблизительно одно и то же, но в JavaScript
        эти понятия заметно отличаются. <code>Undefined</code> — значение, которое
        может храниться в объявленной переменной. <b><i>«Не объявлено»</i></b>
        означает, что переменная не была объявлена.</p>

    <p>К сожалению, JavaScript отчасти объединяет эти два термина, не
        только в сообщениях об ошибках (<code>«ReferenceError: a is not
            defined»</code>), но и в возвращаемых значениях оператора <code>typeof</code>,
        который в обоих случаях возвращает "<code>undefined</code>".</p>

    <p>Тем не менее защита <code>typeof</code> (предотвращение ошибки) при использовании с необъявленной переменной бывает достаточно
        полезной в некоторых случаях.</p>

</div>

<div class="linear" id="chapter2">

    <h2>Глава 2: Значения</h2>

    <p>Массивы индексируются числами, но есть один нюанс: они также являются объектами, к которым могут добавляться строковые ключи/свойства (не учитываемые
        в длине массива):</p>

    <pre class="brush: js;">
        var a = [ ];
        a[0] = 1;
        a["foobar"] = 2;
        a[1] = 3;

        console.log(a)                      // (2) [1, 3, foobar: 2]
        console.log(a.length)               // 2
    </pre>

    <p>Но здесь кроется ловушка: если строковое значение, которое
        должно использоваться в качестве ключа, может быть преобразовано в стандартное десятичное число, то предполагается, что
        вы хотите использовать его в качестве числового индекса, а не
        строкового ключа!</p>

    <pre class="brush: js;">
        var b = [ ];
        b["13"] = 42;

        console.log(b)                      // (14) [empty × 13, 42]
        console.log(b.length)               // 14
    </pre>

    <p><b>Подобие массивов</b></p>

    <p>Типичный пример — функции, предоставляющие объект <code>arguments</code> (подобие массива, в ES6 объявлен устаревшим) для обращения к аргументам в виде списка.
        Один очень распространенный способ выполнения таких преобразований основан на вызове функции <code>slice(..)</code>:</p>

    <pre class="brush: js;">
        function foo() {
            var arr = Array.prototype.slice.call( arguments );
            arr.push( "bam" );
            console.log( arr );
        }
        foo( "bar", "baz" ); // ["bar","baz","bam"]
    </pre>

    <p>В ES6 также появилась встроенная функция <code>Array.from(..)</code>,
        которая делает то же самое:</p>

    <pre class="brush: js;">
        var arr = Array.from( arguments );
    </pre>

    <br>

    <p><b>Строки</b></p>

    <p>Строки действительно отчасти напоминают массивы — они являются массивоподобными, как и упоминавшиеся ранее объекты.
        Например, и строки, и массивы поддерживают свойство <code>length</code>,
        метод <code>indexOf(..)</code> (в ES5 только для массивов) и метод <code>concat(..)</code>:</p>

    <pre class="brush: js;">
        var a = "foo";
        var b = ["f","o","o"];

        a.length; // 3
        b.length; // 3

        a.indexOf( "o" ); // 1
        b.indexOf( "o" ); // 1

        var c = a.concat( "bar" ); // "foobar"
        var d = b.concat( ["b","a","r"] ); // ["f","o","o","b","a","r"]

        a === c; // false
        b === d; // false
    </pre>

    <p>Вывестив строку обратном порядке</p>

    <pre class="brush: js;">
        var c = a
            // разбиение `a` на массив символов
        .split( "" )
            // переставить массив символов в обратном порядке
        .reverse()
            // снова объединить массив символов в строку
        .join("");
        c;  // "oof"
    </pre>

    <br>

    <p><b>Числа</b></p>

    <p>Будьте осторожны с оператором <code>.</code>. Поскольку <code>.</code> является действительным символом числа, этот символ сначала будет интерпретирован как часть числового литерала
        (если это возможно), а не как метод доступа к свойству:</p>

    <pre class="brush: js;">
        // неверный синтаксис:
        42.toFixed( 3 ); // SyntaxError

        // все эти варианты допустимы:
        (42).toFixed( 3 ); // "42.000"
        0.42.toFixed( 3 ); // "0.420"
        42..toFixed( 3 ); // "42.000"
    </pre>

    <p>Конструкция <code>42..toFixed(3)</code> работает потому, что первый символ <code>.</code> является частью числа, а второй символ <code>.</code> интерпретируется как оператор свойства. </p>

    <br>

    <p><b>Оператор void</b></p>

    <p> Хотя undefined является встроенным идентификатором, который
        содержит встроенное значение undefined (если он не был изменен,
        см. выше), это значение также можно получить при помощи
        оператора void.</p>

    <p>Выражение void ___ «стирает» любое значение, так что результат
        выражения всегда является неопределенным. Оно не изменяет
        существующего значения, а всего лишь гарантирует, что операторное выражение не вернет никакого значения:</p>

    <pre class="brush: js;">
        var a = 42;
        console.log( void a, a ); // undefined 42
    </pre>

    <p>В общем, если в каком-то месте вашей программы существует
        значение (полученное в результате вычисления некоторого выражения), а вам было бы удобно, чтобы вместо этого значения
        было <code>undefined</code>, используйте оператор <code>void</code>. Скорее всего, такие
        ситуации будут относительно редко встречаться, но в этих редких
        случаях они могут быть полезны.</p>

    <br>

    <p><b>NaN</b></p>

    <p>В ES6 наконец-то появилась замена: <code>Number.isNaN(..)</code>. Простой
        полифил позволит безопасно проверять значения <code>NaN</code> даже в браузерах до ES6:</p>

    <pre class="brush: js;">
        if (!Number.isNaN) {
            Number.isNaN = function(n) {
                return (
                    typeof n === "number" && window.isNaN( n )
                );
            };
        }

        var a = 2 / "foo";
        var b = "foo";

        Number.isNaN( a ); // true
        Number.isNaN( b ); // false — теперь правильно!
    </pre>

    <br>

    <p>В JavaScript массивы представляют собой обычные коллекции
        значений произвольных типов с числовым индексированием.
        Строки отчасти являются <b><i>«массивоподобными»</i></b>, но они обладают
        другим поведением, и, если вы хотите работать с ними как с массивами, необходима осторожность. К категории чисел в JavaScript
        принадлежат как <b><i>«целые»</i></b> значения, так и значения с плавающей
        точкой.</p>

    <p>Среди примитивных типов определены несколько специальных
        значений.</p>

    <p>Тип <code>null</code> имеет всего одно значение <code>null</code>; аналогичным образом
        тип <code>undefined</code> имеет единственное значение <code>undefined</code>. По сути,
        <code>undefined</code> является значением по умолчанию любой переменной
        или свойства при отсутствии других значений. Оператор <code>void</code>
        позволяет создать значение <code>undefined</code> из любого другого значения.</p>

    <p> К числовому типу <code>number</code> относятся некоторые специальные
        значения, такие как <code>NaN</code> (вроде бы <b><i>«не число»</i></b>, но правильнее
        было бы <b><i>«недействительное число»</i></b>), <code>+Infinity</code>, <code>-Infinity</code> и <code>-0</code>.</p>

    <p><b><i>Простые скалярные примитивы</i></b> (строки, числа и т. д.) присваиваются/передаются копированием значения, но составные значения (объекты и т. д.) присваиваются/передаются копированием ссылки. Ссылки JavaScript не похожи на ссылки/указатели
        других языков — они никогда не указывают на другие переменные/ссылки, а только на используемые значения.</p>

</div>

<div class="linear" id="chapter3">

    <h2>Глава 3: Встроенные объекты (natives)</h2>

    <ul class="ul_num">
        <li>String()</li>
        <li>Number() </li>
        <li>Boolean() </li>
        <li>Array() </li>
        <li>Object()</li>
        <li>Function()</li>
        <li>RegExp() </li>
        <li>Date() </li>
        <li>Error() </li>
        <li>Symbol() — начиная с ES6!</li>
    </ul>
    
    <p>Как видите, эти встроенные «объекты» на самом деле представляют собой встроенные функции</p>

    <br>

    <p><b>Symbol(..)</b></p>

    <p>В ES6 появился новый примитивный тип значений <code>Symbol</code>. Значения этого типа — <b><i>символические имена</i></b> — представляют собой
        специальные <b><i>«уникальные»</i></b> (без гарантий полной уникальности!) значения, которые могут использоваться как свойства
        объектов с минимальным риском конфликтов. Они в основном
        создавались для специальных встроенных аспектов поведения
        конструкций ES6, но вы также можете определять собственные
        символические имена.</p>

    <p>Символические имена могут использоваться как имена свойств,
        но вы не сможете просмотреть фактическое значение символьного имени или обратиться к нему ни из своей программы, ни
        с консоли разработчика. Если попытаться вычислить символическое имя на консоли разработчика, будет выведен результат
        вида <code>Symbol(Symbol.create)</code>.</p>

    <p>В ES6 есть несколько заранее определенных символических
        имен, для обращения к которым используются статические
        свойства объекта функции <code>Symbol: Symbol.create</code>, <code>Symbol.iterator</code>
        и т. д. Пример их использования:</p>

    <pre class="brush: js;">
        obj[Symbol.iterator] = function(){ /*..*/ };
    </pre>

    <br>

    <b>Встроенные прототипы</b>

    <ul class="ul_num">
        <li><code>String.indexOf(..)</code> — вернуть индекс позиции по символу </li>
        <li><code>String.charAt(..)</code> — вернуть символ по индексу.</li>
        <li><code>String.substr(..)</code> — извлечь из строки определенное количество символов, начиная с заданного индекса.</li>
        <li><code>String.substring(..)</code>  — извлечь символы из строки (подстроку) между двумя заданными индексами, или от определенного индекса до конца строки.</li>
        <li><code>String.slice(..)</code> — позволяет возвратить новый массив, который содержит копии элементов, вырезанных из исходного массива.</li>
        <li><code>String.toUpperCase()</code> и <code>String.toLowerCase()</code> — создает новую
            строку, которая преобразуется к верхнему или нижнему регистру.</li>
        <li><code>String.trim()</code> — создает новую строку, из которой удалены
            все начальные или конечные пропуски</li>
    </ul>

    <p>JavaScript предоставляет объектные обертки для примитивных
        значений (String, Number, Boolean и т. д.). Объектные обертки
        предоставляют значениям доступ к поведению, соответствующему каждому подтипу объекта (String#trim()и Array#concat(..)).</p>

    <p>Если у вас имеется простое скалярное примитивное значение
        (например, "abc") и вы обращаетесь к его свойству length или
        вызываете некий метод String.prototype, JS автоматически «упаковывает» значение (заключает его в соответствующую объектную обертку), для того чтобы реализовать обращение к свойству/
        методу</p>

</div>

<div class="linear" id="chapter4">

    <h2>Глава 4: Преобразование типов</h2>

    <br>

    <p><b>Преобразование даты в число</b></p>

    <pre class="brush: js;">
        var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );
        +d; // 1408369986000
    </pre>

    <br>

    <p><b>Явные преобразования: * --> Boolean</b></p>

    <pre class="brush: js;">
        var a = "0";
        var b = [];
        var c = {};

        var d = "";
        var e = 0;
        var f = null;
        var g;

        Boolean( a ); // true
        Boolean( b ); // true
        Boolean( c ); // true

        Boolean( d ); // false
        Boolean( e ); // false
        Boolean( f ); // false
        Boolean( g ); // false


            // тоже самое преобразование к Boolean
        !!a; // true
        !!b; // true
        !!c; // true

        !!d; // false
        !!e; // false
        !!f; // false
        !!g; // false
    </pre>

    <br>

    <p><b>Операторы || и &&</b></p>

    <pre class="brush: js;">
        var a = 42;
        var b = "abc";
        var c = null;

        a || b; // 42
        a && b; // "abc"

        c || b; // "abc"
        c && b; // null
    </pre>

    <p>Что касается оператора <code>||</code>, если условие истинно, то результатом
        выражения <code>||</code> становится значение первого операнда (<code>a</code> или <code>c</code>).
        Если же условие ложно, то результатом выражения <code>||</code> становится значение второго операнда (<code>b</code>).</p>

    <p>И наоборот, для оператора <code>&&</code>, если условие истинно, то результатом выражения <code>&&</code> становится значение второго операнда (<code>b</code>).
        Если же условие ложно, то результатом выражения <code>&&</code> становится значение первого операнда (<code>a</code> или <code>c</code>).</p>

    <p>На эти операторы можно взглянуть иначе:</p>

    <pre class="brush: js;">
        a || b;
            // приблизительно эквивалентно:
        a ? a : b;

        a && b;
            // приблизительно эквивалентно:
        a ? b : a;
    </pre>

    <br>

    <p><b>Сравнение: null с undefned</b></p>

    <ul class="ul_num">
        <li>Если <code>x</code> содержит <code>null</code>, а <code>y</code> содержит <code>undefined</code>, вернуть <code>true</code>.</li>
        <li>Если <code>x</code> содержит <code>undefined</code>, а <code>y</code> содержит <code>null</code>, вернуть <code>true</code></li>
    </ul>

    <p><code>Null</code> и <code>undefined</code> при сравнении нестрогим оператором <code>==</code> равны
        друг другу (то есть преобразуются друг к другу), и никаким
        другим значениям во всем языке.</p>

    <pre class="brush: js;">
        var a = null;
        var b;

        a == b; // true
        a == null; // true
        b == null; // true

        a == false; // false
        b == false; // false
        a == ""; // false
        b == ""; // false
        a == 0; // false
        b == 0; // false
    </pre>

    <br>

    <p><b>Сравнение: объекты и необъекты</b></p>

    <ul class="ul_num">
        <li>Если <code>Type(x)</code> относится к типу <code>String</code> или <code>Number</code>, а <code>Type(y)</code>
            относится к типу <code>Object</code>, вернуть результат сравнения <code>x == ToPrimitive(y)</code>.</li>
        <li>Если <code>Type(x)</code> относится к типу <code>Object</code>, а <code>Type(y)</code> относится
            к типу <code>String</code> или <code>Number</code>, вернуть результат сравнения
            <code>ToPrimitive(x) == y</code>.</li>
    </ul>

    <pre class="brush: js;">
        var a = 42;
        var b = [ 42 ];

        a == b; // true
    </pre>

    <p>Для значения <code>[ 42 ]</code> вызывается абстрактная операция <code>ToPrimitive</code>
        (см. «Абстрактные операции»), которая дает результат <code>"42"</code>.
        С этого момента остается простое условие <code>"42" == 42</code>, которое,
        как мы уже выяснили, превращается в <code>42 == 42</code>, так что <code>a</code> и <code>b</code>
        равны с точностью до преобразования типа.</p>

    <br>

    <p><b>Сравнения ложных значений</b></p>

    <p>Самые распространенные претензии к неявным преобразованиям при сравнениях == происходят от странностей поведения
        ложных значений при сравнении их друг с другом.</p>

    <p>Для наглядности рассмотрим список особых случаев при сравнениях ложных значений. Вы сами увидите, какие варианты
        разумны, а какие создают проблемы:</p>

    <pre class="brush: js;">
        "0" == null;            // false
        "0" == undefined;       // false
        "0" == false;           // true – ОЙ-ОЙ!
        "0" == NaN;             // false
        "0" == 0;               // true
        "0" == "";              // false

        false == null;          // false
        false == undefined;     // false
        false == NaN;           // false
        false == 0;             // true – ОЙ-ОЙ!
        false == "";            // true – ОЙ-ОЙ!
        false == [];            // true – ОЙ-ОЙ!
        false == {};            // false

        "" == null;             // false
        "" == undefined;        // false
        "" == NaN;              // false
        "" == 0;                // true – ОЙ-ОЙ!
        "" == [];               // true – ОЙ-ОЙ!
        "" == {};               // false

        0 == null;              // false
        0 == undefined;         // false
        0 == NaN;               // false
        0 == [];                // true – ОЙ-ОЙ!
        0 == {};                // false
    </pre>

</div>

<div class="linear" id="chapter5">

    <h2>Глава 5: Грамматика</h2>

   <p>Оператор серии команд <code>,</code> (запятая). Этот оператор позволяет сцепить несколько отдельных команд-выражений в одну команду:</p>

    <pre class="brush: js;">
        var a = 42, b;
        b = ( a++, a );

        a;      // 43
        b;      // 43
    </pre>

    <p>Выражение <code>a++</code>, <code>a</code> означает, что второе подвыражение <code>a</code> будет
        вычисляться после завершающих побочных эффектов выражения
        <code>a++</code>; это означает, что оно вернет значение <code>43</code> для присваивания <code>b</code>.</p>

    <p><b><i>Применение идиомы, использующее побочный эффект присваивания</i></b></p>

    <pre class="brush: js;">
        function vowels(str) {
            var matches;
                // извлечение гласных
            if (str && (matches = str.match( /[aeiou]/g ))) {
                return matches;
            }
        }
        vowels( "Hello World" ); // ["e","o","o"]
    </pre>

    <p>Круглые скобки <code>( .. )</code> вокруг <code>matches = str.match..</code> обязательны. Это связано с приоритетом операторов, который
        будет рассматриваться в следующей главе.</p>
		
	<br>
	
	<p><b>Деструктуризация объектов</b></p>
	
	<p>Начиная с ES6 пары <code>{ .. }</code> также могут встретиться при вы-
полнении «деструктурирующего присваивания», а конкретно
при деструктуризации объектов. Пример:</p>
	
	<pre class="brush: js;">
		function getData() {
			return {
				a: 42,
				b: "foo"
			};
		}
		
		var { a, b } = getData();
		console.log( a, b ); // 42 "foo"
	</pre>
	
	<p><code>var { a , b } = ..</code> — форма деструктурирующего присваивания ES6, которая приблизительно
	эквивалентна следующей серии команд:</p>

	<pre class="brush: js;">
		var res = getData();
		var a = res.a;
		var b = res.b;
	</pre>
	  
	<p>Деструктуризация объектов парой <code>{ .. }</code> также может использоваться для именованных аргументов функций, удобная запись
	для аналогичного неявного присваивания значений свойств:</p>

	<pre class="brush: js;">
	function foo({ a, b, c }) {
		// не нужно:
		// var a = obj.a, b = obj.b, c = obj.c
		console.log( a, b, c );
	}
	foo( {
		c: [1,2,3],
		a: 42,
		b: "foo"
	} ); 		// 42 "foo" [1, 2, 3]
	</pre>
	
	<br>

	<p><b>Приоритет операторов</b></p>

	<pre class="brush: js;">
		(false && true) || true; // true
		false && (true || true); // false
		
		false && true || true; // true
		(false && true) || true; // true
			//Оператор && вычисляется первым, а оператор ||  вычисляется вторым.
			
		true || false && false; // true
		(true || false) && false; // false
		true || (false && false); // true
	</pre>	
	
	<br>
	
	<p><b>Плотное связывание</b></p>
	
	<pre class="brush: js;">
		// Этот код
	a && b || c ? c || b ? a : c && b : a

		//Будет обрабатываться так:
	(a && b || c) ? (c || b) ? a : (c && b) : a
	</pre>
	
	<p>Потому что <code>&&</code> обладает более высоким приоритетом, чем <code>||</code> , а <code>||</code> — более высоким приоритетом, чем <code>? :</code> .</p>

	<p>Таким образом, выражение <code>(a && b || c)</code>  будет вычислено до
	вычисления оператора <code>? :</code> , в котором оно участвует. Также
	часто говорят, что <code>&&</code> и <code>||</code>  «связываются плотнее», чем <code>? :</code> . Если
	бы было справедливо обратное, то c <code>? c</code> были бы связаны
	плотнее, и вся конструкция обладала бы поведением первого
	варианта — <code>a && b || (c ? c)</code> .</p>
	
	<br>
	
	<p><b>Ассоциативность</b></p>
	
	<pre class="brush: js;">
			// Этот код
		a ? b : c ? d : e;

			//Будет обрабатываться так:
		a ? b : (c ? d : e) 
		
		
			// Ещё пример
		true ? false : true ? true : true; // false
		true ? false : (true ? true : true); // false
		(true ? false : true) ? true : true; // true
		
		
			// Ещё пример
		true ? false : true ? true : false; // false
		true ? false : (true ? true : false); // false
		(true ? false : true) ? true : false; // false
		
			// Ещё пример
		var a = true, b = false, c = true, d = true, e = false;
		a ? b : (c ? d : e); 	// false, вычисляет только `a` и `b`
		(a ? b : c) ? d : e; 	// false, вычисляет только `a`, `b` и `e`
	</pre>
	
	<br>
	
	<p><b>try..catch..finally</b></p>
	
	<pre class="brush: js;">
		try {
		   .. пробуем выполнить код ..
		} catch(e) {
		   .. перехватываем исключение ..
		} finally {
		   .. выполняем всегда ..
		}
	</pre>

	<pre class="brush: js;">
		try {

			// код ...
			
			if (!user.name) {
				throw new SyntaxError("Данные некорректны");
			}

		} catch (err) {
			
			// обработка ошибки
			
		} finally {
			
			// .. выполняем всегда ..
			
		}
	</pre>
	
	<p>Оператор <code>throw</code> генерирует ошибку.</p>
	<p>Синтаксис: <code>throw <объект ошибки></code>.</p>
	
	<p>Технически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно – совместимый со стандартным, то есть чтобы у него были как минимум свойства <code>name</code> и <code>message</code>.</p>
	<p>В качестве конструктора ошибок можно использовать встроенный конструктор: <code>new Error(message)</code> или любой другой.</p>
	<p>В JavaScript встроен ряд конструкторов для стандартных ошибок: <code>SyntaxError</code>, <code>ReferenceError</code>, <code>RangeError</code> и некоторые другие. Можно использовать и их, но только чтобы не было путаницы.</p>

	<br>
	
	<p>Секция <code>finally</code> не обязательна, но если она есть, то она выполняется всегда:</p>
	
	<ul class="ul_num">
		<li>после блока <code>try</code>, если ошибок не было</li>
		<li>после catch, если они были</li>
	</ul>

	<p>Секцию <code>finally</code> используют, чтобы завершить начатые операции при любом варианте развития событий.</p>
	


</div>

<!--
<code></code>
<p></p>
<p><b></b></p>
<pre class="brush: js;">

</pre>

<div class="linear" id="chapter5">

    <h2>Глава 5: </h2>


</div>

<ul class="ul_num">
    <li></li>
</ul>

Разрешение экрана:
ширина: 1280 - 1264
высота: 800
-->

<?php include $_SERVER['DOCUMENT_ROOT'].'/include/footer.php'; ?>
