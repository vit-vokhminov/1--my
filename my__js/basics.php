<?php include '../include/header.php'; ?>


    <div class="linear" id="use_strict">
        <h1>Строгий режим — "use strict"</h1>

        <p>
            В 2009 году вышел ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих.
            <b>Чтобы старый код работал, большинство таких модификаций по умолчанию отключены.</b> Вы должны явно включить их с
            помощью специальной директивы: <code>"use strict"</code>.
        </p>
        <h2>«use strict»</h2>

        <p>Директива выглядит как строка: <code>"use strict"</code> или <code>'use strict'</code>. Когда она находится в начале скрипта, весь
            сценарий работает в «современном» режиме.</p>
        <p>Например:</p>

        <pre class="brush: js;">
            "use strict";

            // этот код работает в современном режиме
            ...
        </pre>


        <p>На данный момент достаточно иметь общее понимание об этом режиме:</p>
        <ul class="ul_num">
            <li>Директива <code>"use strict"</code> переключает движок в «современный» режим, изменяя поведение некоторых встроенных функций. Позже в учебнике мы увидим подробности.</li>
            <li>Строгий режим включается путём размещения <code>"use strict"</code> в начале скрипта или функции. Некоторые функции языка, такие как «классы» и «модули», автоматически включают строгий режим.</li>
            <li>Строгий режим поддерживается всеми современными браузерами.</li>
            <li>Мы рекомендуем всегда начинать скрипты с <code>"use strict"</code>. Все примеры в этом руководстве предполагают строгий режим, если (очень редко) не указано иное.</li>
        </ul>

    </div>

    <div class="linear" id="variable">
        <h1>Переменные</h1>
        <h2>Переменная</h2>

        <p>Приведённая ниже инструкция создаёт (другими словами: объявляет или определяет) переменную с именем «message»:</p>


        <pre class="brush: js;">
           var message = 'Hello';
        </pre>


        <p>В старые времена было технически возможно создать переменную простым присвоением значения без использования <code>let</code>. Это все ещё работает, если мы не включаем <code>use strict</code></p>


        <pre class="brush: js;">
           // заметка: "use strict" в этом примере не используется

            num = 5; // если переменная "num" раньше не существовала, она создаётся

            alert(num); // 5


            /*а если использовать use strict*/


            "use strict";

            num = 5; // error: num is not defined
        </pre>



        <h4>Константы</h4>

        <p>Чтобы объявить константную, то есть, неизменяемую переменную, используйте <code>const</code> вместо <code>let</code>:</p>

        <pre class="brush: js;">
            const myBirthday = '18.04.1982';
        </pre>

        <p>Переменные объявленные с помощью <code>const</code>, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:</p>

        <pre class="brush: js;">
            const myBirthday = '18.04.1982';

            myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
        </pre>



        <h4>Переменная <code>var</code></h4>
        <p>В старых скриптах вы также можете найти другое ключевое слово: <code>var</code> вместо <code>let</code>:</p>

        <pre class="brush: js;">
           var message = 'Hello';
        </pre>

        <p>Область видимости переменных <code>var</code> ограничивается либо функцией, либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.</p>
        <p>Например:</p>

        <pre class="brush: js;">
            if (true) {
                var test = true; // используем var вместо let
            }

            alert(test); // true, переменная существует за блоком if
        </pre>

        <p>Так как <code>var</code> игнорирует блоки, мы получили глобальную переменную <code>test</code>.</p>

        <p>А если бы мы использовали <code>let test</code> вместо <code>var test</code>, тогда переменная была бы видна только внутри <code>if</code>:</p>

        <pre class="brush: js;">
            if (true) {
                let test = true; // используем let
            }

            alert(test); // Error: test is not defined


            /*ИЛИ*/


            for (var i = 0; i < 10; i++) {
              // ...
            }

            alert(i); // 10, переменная i доступна вне цикла, т.к. является глобальной переменной


            /*Если блок кода находится внутри функции, то var становится локальной переменной в этой функции:*/

            function sayHi() {
                if (true) {
                    var phrase = "Привет";
                }

                alert(phrase); // срабатывает и выводит "Привет"
            }

            sayHi();
            alert(phrase); // Ошибка: phrase не определена (видна в консоли разработчика)
        </pre>

       <p>Как видим, var выходит за пределы блоков <code>if</code>, <code>for</code> и подобных. Это происходит потому, что на заре развития
           JavaScript блоки кода не имели лексического окружения. Поэтому можно сказать что, <code>var</code> – это пережиток прошлого.</p>


        <h4>«var» обрабатываются в начале запуска функции</h4>

        <p>Объявления переменных <code>var</code> обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).
            Переменные var считаются объявленными с самого начала функции, вне зависимости от того, в каком месте функции реально находится её объявление
            (при условии, что оно не находится во вложенной функции).</p>

        <pre class="brush: js;">
            function sayHi() {
                phrase = "Привет";

                alert(phrase);

                var phrase;
            }
            sayHi();


            /*…Технически полностью эквивалентен следующему (объявление переменной var phrase перемещено в начало функции):*/


            function sayHi() {
                var phrase;

                phrase = "Привет";

                alert(phrase);
            }
            sayHi();
        </pre>


        <h4>Объявления переменных «всплывают», но присваивания значений – нет.</h4>


        <pre class="brush: js;">
            function sayHi() {
                alert(phrase);

                var phrase = "Привет";
            }

            sayHi();
        </pre>

        <p>Строка <code>var phrase = "Привет"</code> состоит из двух действий:</p>

        <ul class="ul_num">
            <li>Объявление переменной <code>var</code></li>
            <li>Присвоение значения в переменную <code>=</code>.</li>
        </ul>

        <p>Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:</p>

        <pre class="brush: js;">
            function sayHi() {
                var phrase; // объявление переменной срабатывает вначале...

                alert(phrase); // undefined

                phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
            }

            sayHi();
        </pre>

        <h5>Итого</h5>

        <ul class="ul_num">
            <li>Переменные <code>var</code> не имеют блочной области видимости, они ограничены, как минимум, телом функции.</li>
            <li>Объявления (инициализация) переменных <code>var</code> производится в начале исполнения функции (или скрипта для глобальных).</li>
        </ul>

    </div>


    <div class="linear" id="types">
        <h1>Типы данных</h1>

        <p>
            Есть семь основных типов данных в JavaScript.
        </p>

        <h2>Infinity</h2>
        <p><code>Infinity</code> представляет собой математическую бесконечность &infin;. Это особое значение, которое больше любого числа.</p>

        <h2>NaN</h2>
        <p><code>NaN</code> означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:</p>

        <pre class="brush: js;">
               alert( "не число" / 2 ); // NaN, такое деление является ошибкой
        </pre>

        <h2>null</h2>
        <p>Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».</p>

        <h2>undefined</h2>
        <p>Оно означает, что «значение не было присвоено».</p>

        <pre class="brush: js;">
            let x;

            alert(x); // выведет "undefined"
        </pre>

        <h2>Строка</h2>
        <ul class="ul_num">
           <li>Двойные кавычки: <code>"Привет"</code>.</li>
           <li>Одинарные кавычки: <code>'Привет'</code>.</li>
           <li>Обратные кавычки: <code>`Привет`</code>.</li>
        </ul>

        <p>Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.</p>
        <p>Обратные кавычки же имеют «расширенный функционал». Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:</p>


        <pre class="brush: js;">
            let name = "Иван";

            // Вставим переменную
            alert( `Привет, ${name}!` ); // Привет, Иван!

            // Вставим выражение
            alert( `результат: ${1 + 2}` ); // результат: 3
        </pre>

        <p>Выражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную name или выражение 1 + 2, или что-то более сложное.<br>
            Зто можно делать только в обратных кавычках. Другие кавычки не имеют такого функционала встраивания!</p>

        <pre class="brush: js;">
            alert( "результат: ${1 + 2}" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)
        </pre>

        <h2>Оператор typeof</h2>

        <p>Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.</p>
        <p>У него есть два синтаксиса:</p>

        <ul class="ul_num">
            <li>Синтаксис оператора: typeof x.</li>
            <li>Синтаксис функции: typeof(x).</li>
        </ul>

        <pre class="brush: js;">
            typeof undefined // "undefined"
            typeof 0 // "number"
            typeof true // "boolean"
            typeof "foo" // "string"
            typeof Symbol("id") // "symbol"
            typeof Math // "object"  (1)
            typeof null // "object"  (2)
            typeof alert // "function"  (3)
        </pre>


        <h2>Итого</h2>

        <p>В JavaScript есть 7 основных типов.</p>

        <ul class="ul_num">
            <li>number для любых чисел: целочисленных или чисел с плавающей точкой.</li>
            <li>string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа.</li>
            <li>boolean для true/false.</li>
            <li>null для неизвестных значений – отдельный тип, имеющий одно значение null.</li>
            <li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.</li>
            <li>object для более сложных структур данных.</li>
            <li>symbol для уникальных идентификаторов.</li>
        </ul>

        <p>Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.</p>

        <ul class="ul_num">
            <li>Имеет две формы: typeof x или typeof(x).</li>
            <li>Возвращает строку с именем типа. Например, "string".</li>
            <li>Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.</li>
        </ul>

    </div>


    <div class="linear" id="type-conversions">
        <h1>Преобразование типов</h1>

        <h2>Строковое преобразование</h2>

        <pre class="brush: js;">
            let value = true;
            alert(typeof value); // boolean

            value = String(value); // теперь value это строка "true"
            alert(typeof value); // string
        </pre>

        <p>Преобразование происходит очевидным способом. <code>false</code> становится <code>"false"</code>, <code>null</code> становится <code>"null"</code> и т.п.</p>


        <h2>Численное преобразование</h2>

        <p>Численное преобразование происходит в математических функциях и выражениях.</p>
        <p>Например, когда операция деления <code>/</code> применяется не к числу:</p>

        <pre class="brush: js;">
            alert( "6" / "2" ); // 123
        </pre>

        <p>При преобразовании строки, пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то <code>0</code>, иначе из непустой строки «считывается» число. При ошибке результат <code>NaN</code>.</p>

        <pre class="brush: js;">
            alert( Number("   123   ") ); // 123
            alert( Number("123z") );      // NaN (ошибка чтения числа в "z")
            alert( Number(true) );        // 1
            alert( Number(false) );       // 0
            alert( Number(null) );        // 0
            alert( Number(undefined) );   // NaN
        </pre>

        <p>Преобразование происходит очевидным способом. <code>false</code> становится <code>"false"</code>, <code>null</code> становится <code>"null"</code> и т.п.</p>

        <h2>Сложение „+“ объединяет строки</h2>

        <p>Почти все математические операторы выполняют численное преобразование. Исключение составляет <code>+</code>. Если одно из слагаемых является строкой, тогда и все остальные приводятся к строкам.</p>
        <p>Тогда они конкатенируются (присоединяются) друг к другу:</p>

        <pre class="brush: js;">
            alert( 1 + '2' ); // '12' (строка справа)
            alert( '1' + 2 ); // '12' (строка слева)
        </pre>

        <p>Так происходит, только если хотя бы один из аргументов является строкой. Во всех остальных случаях значения складываются как числа.</p>

        <h2>Итого</h2>

        <pre class="brush: js;">
            "" + 1 + 0 = "10"           // (1)
            "" - 1 + 0 = -1             // (2)
            true + false = 1
            6 / "3" = 2
            "2" * "3" = 6
            4 + 5 + "px" = "9px"
            "$" + 4 + 5 = "$45"
            "4" - 2 = 2
            "4px" - 2 = NaN
            7 / 0 = Infinity
            " -9  " + 5 = " -9  5"      // (3)
            " -9  " - 5 = -14           // (4)
            null + 1 = 1                // (5)
            undefined + 1 = NaN         // (6)
            " \t \n" - 2 = -2           // (7)
        </pre>

        <ul class="ul_num">
            <li>Сложение со строкой <code>"" + 1</code> преобразует <code>1</code> к строке: <code>"" + 1 = "1"</code>, и в следующем случае <code>"1" + 0</code>, работает то же самое правило.</li>
            <li>Вычитание <code>-</code> (как и большинство математических операторов) работает только с числами, пустая строка <code>""</code> приводится к <code>0</code>.</li>
            <li>Сложение со строкой превращает число <code>5</code> в строку и добавляет к строке.</li>
            <li>Вычитание всегда преобразует к числу, значит строка <code>" -9 "</code> становится числом <code>-9</code> (пробелы по краям обрезаются).</li>
            <li><code>null</code> становится <code>0</code> после численного преобразования.</li>
            <li><code>undefined</code> становится <code>NaN</code> после численного преобразования.</li>
            <li>Пробельные символы, такие как <code>\t и \n</code> по краям строки игнорируются при преобразовании в число, так что строка <code>\t \n</code>, аналогично пустой строке, становится <code>0</code> после численного преобразования.</li>
        </ul>


    </div>


    <div class="linear" id="operators">
        <h1>Операторы</h1>

        <h2>Термины: «унарный», «бинарный», «операнд»</h2>


        <ul class="ul_num">
            <li>
                <p><i>Операнд</i> – то, к чему применяется оператор. Например, в умножении <code>5 * 2</code> есть два операнда: левый операнд равен <code>5</code>, а правый операнд равен <code>2</code>. Иногда их называют «аргументами» вместо «операндов».</p>
            </li>
            <li>
                <p><i>Унарным</i> называется оператор, который применяется к одному операнду. Например, оператор унарный минус <code>"-"</code> меняет знак числа на противоположный:</p>
                <pre class="brush: js;">
                   let x = 1;

                    x = -x;
                    alert( x ); // -1, применили унарный минус
                </pre>
            </li>
            <li>
                <p><i>Бинарным</i> называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:</p>
                <pre class="brush: js;">
                    let x = 1, y = 3;
                    alert( y - x ); // 2, бинарный минус
                </pre>
            </li>
        </ul>

        <h2>Преобразование к числу, унарный плюс +</h2>

        <p>Унарный плюс <code>+</code> ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.</p>

        <pre class="brush: js;">
            // Преобразует не-числа в число
            alert( +true ); // 1
            alert( +"" );   // 0


            let apples = "2";
            let oranges = "3";

            // оба операнда предварительно преобразованы в числа
            alert( +apples + +oranges ); // 5

            // более длинный вариант
            // alert( Number(apples) + Number(oranges) ); // 5
        </pre>

        <p>На самом деле это то же самое, что и <code>Number(...)</code>, только короче.</p>


        <h2>Возведение в степень **</h2>

        <p>Оператор возведения в степень <code>**</code> недавно добавили в язык.</p>

        <pre class="brush: js;">
            alert( 2 ** 2 ); // 4  (2 * 2)
            alert( 2 ** 3 ); // 8  (2 * 2 * 2)
            alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)


            alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
            alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)
        </pre>


        <h2>Инкремент/декремент</h2>

        <ul class="ul_num">
            <li><b>Инкремент</b> <code>++</code> увеличивает на 1:</li>
            <li><b>Декремент</b> <code>--</code> уменьшает на 1:</li>
        </ul>

        <p>Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).</p>

        <pre class="brush: js;">
            let counter = 1;
            let a = ++counter; // (*)

            alert(a); // 2
                //префиксная форма увеличения counter, и возвращает новое значение 2.



            let counter = 1;
            let a = counter++; // (*) меняем ++counter на counter++

            alert(a); // 1
                //постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения)



            let a = 1, b = 1;

            alert( ++a );       // 2, префиксная форма возвращает новое значение
            alert( b++ );       // 1, постфиксная форма возвращает старое значение

            alert( a );         // 2, значение увеличено один раз
            alert( b );         // 2, значение увеличено один раз
        </pre>

        <h2>Сокращённая арифметика с присваиванием</h2>


        <pre class="brush: js;">
           let n = 2;

            n *= 3 + 5;

            alert( n );         // 16  (сначала выполнится правая часть, превратив выражение в n *= 8)



            let a = 2;

            let x = 1 + (a *= 2);

             alert( a );        // 4 (умножено на 2)
             alert( x );        // 5 (вычислено как 1 + 4)

        </pre>


       <h2>Оператор запятая</h2>

        <p>Оператор запятая предоставляет нам возможность вычислять несколько выражений, разделяя их запятой <code>,</code>. Каждое выражение выполняется, но возвращается результат только последнего.</p>

        <pre class="brush: js;">
            let a = (1 + 2, 3 + 4);

            alert( a ); // 7 (результат 3 + 4)
        </pre>

        <p>Запятая имеет очень низкий приоритет, поэтому в этих примера скобки важны</p>
        <pre class="brush: js;">
            let a = 1 + 2, 3 + 4;

            alert( a ); // 3
        </pre>
        <p>Без них в <code>a = 1 + 2, 3 + 4</code> сначала выполнится <code>+</code>, суммируя числа в <code>a = 3, 7</code>, затем оператор присваивания <code></code> присвоит <code>a = 3</code>, а то что идёт дальше, будет игнорировано. Всё так же, как в <code>(a = 1 + 2), 3+4</code>.</p>


    </div>



    <div class="linear" id="ifelse">
        <h1>Условные операторы: if, '?'</h1>

        <h2>Преобразование к логическому типу</h2>

        <p>Число <code>0</code>, пустая строка <code>""</code>, <code>null</code>, <code>undefined</code> и <code>NaN</code> становятся false. Из-за этого их называют «ложными» («falsy») значениями.:</p>
        <p>Остальные значения становятся <code>true</code>, поэтому их называют «правдивыми» («truthy»).</p>


        <h2>Условный оператор „?“</h2>

        <p>Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.</p>

        <pre class="brush: js;">
            let result = условие ? значение1 : значение2;


            // оператор сравнения "age > 18" выполняется первым в любом случае
            // (нет необходимости заключать его в скобки, но скобки делают код более читабельным)
            let accessAllowed = (age > 18) ? true : false;
            if(accessAllowed){
                alert('Ура!');
            }

            // то же самое
            let accessAllowed = age > 18;
        </pre>

        <h2>Несколько операторов „?“</h2>


        <pre class="brush: js;">
            let age = prompt('Возраст?', 18);

            let message = (age < 3) ? 'Здравствуй, малыш!' :
                (age < 18) ? 'Привет!' :
                (age < 100) ? 'Здравствуйте!' :
                'Какой необычный возраст!';

            alert( message );


            //Аналогично
            if (age < 3) {
                message = 'Здравствуй, малыш!';
            } else if (age < 18) {
                message = 'Привет!';
            } else if (age < 100) {
                message = 'Здравствуйте!';
            } else {
                message = 'Какой необычный возраст!';
            }
        </pre>

    </div>

    <div class="linear" id="logical-operators">
        <h1>Логические операторы</h1>

        <p>В JavaScript есть три логических оператора: <code>||</code> (ИЛИ), <code>&&</code> (И) и <code>!</code> (НЕ).</p>

        <h2>! (НЕ)</h2>

        <ul class="ul_num">
            <li>Сначала приводит аргумент к логическому типу <code>true/false</code>.</li>
            <li>Затем возвращает противоположное значение.</li>
        </ul>

        <p>В частности, двойное НЕ используют для преобразования значений к логическому типу:</p>

        <pre class="brush: js;">
            alert( !!"non-empty string" );          // true
            alert( !!null );                        // false

            //Аналогично использованию встроенной функции Boolean:
            alert( Boolean("non-empty string") );   // true
            alert( Boolean(null) );                 // false
        </pre>

    </div>


    <div class="linear" id="while-for">
        <h1>Циклы while и for</h1>

        <p>Одно выполнение тела цикла по-научному называется <i>итерация</i>.</p>

        <h2>Цикл «while»</h2>

        <pre class="brush: js;">
            let i = 0;
            while (i < 3) { // выводит 0, затем 1, затем 2
                alert( i );
                i++;
            }


            //Ещё пример
            let i = 3;
            while (i) alert(i--);
        </pre>


        <h2>Цикл «do…while»</h2>

        <p>Цикл сначала выполнит тело, а затем проверит условие <code>condition</code>, и пока его значение равно <code>true</code>, он будет выполняться снова и снова.</p>


        <pre class="brush: js;">
            let i = 0;
            do {
                alert( i );
                i++;
            } while (i < 3);
        </pre>


        <h2>Прерывание цикла: «break»</h2>

        <pre class="brush: js;">
            let sum = 0;

            while (true) {
              let value = +prompt("Введите число", '');
              if (!value) break;                            // (*)
              sum += value;
            }
            alert( 'Сумма: ' + sum );
        </pre>

        <p>Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на <code>alert</code>.</p>


        <h2>Переход к следующей итерации: continue</h2>

        <pre class="brush: js;">
            for (let i = 0; i < 10; i++) {

                // если true, пропустить оставшуюся часть тела цикла
                if (i % 2 == 0) continue;

                alert(i); // 1, затем 3, 5, 7, 9
            }
        </pre>

    </div>


    <div class="linear" id="switch">
        <h1>Конструкция "switch"</h1>

        <p>Конструкция <code>switch</code> заменяет собой сразу несколько <code>if</code>. При сравнении она использует оператор строгого равенства <code>===.</code></p>

        <p>Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.</p>


        <pre class="brush: js;">
            let a = 2 + 2;

            switch (a) {
              case 3:
                alert( 'Маловато' );
                break;
              case 4:
                alert( 'В точку!' );
                break;
              case 5:
                alert( 'Перебор' );
                break;
              default:
                alert( "Нет таких значений" );
            }
        </pre>

        <ul class="ul_num">
            <li>Переменная <code>a</code> проверяется на строгое равенство первому значению <code>value1</code>, затем второму <code>value2</code> и так далее.</li>
            <li>Если соответствие установлено – <code>switch</code> начинает выполняться от соответствующей директивы <code>case</code> и далее, до ближайшего <code>break</code> (или до конца <code>switch</code>).</li>
            <li>Если ни один <code>case</code> не совпал – выполняется (если есть) вариант <code>default</code>.</li>
        </ul>

        <p><b>Если <code>break</code> нет, то выполнение пойдёт ниже по следующим <code>case</code>, при этом остальные проверки игнорируются.</b></p>
        <p>В примере выше, если бы не было <code>break</code>, топоследовательно выполнятся все четыре <code>alert</code>:</p>


        <h2>Группировка «case» и Тип имеет значение</h2>

        <pre class="brush: js;">
            let arg = prompt("Введите число?");
            switch (arg) {
                case '0':
                case '1':
                    alert( 'Один или ноль' );
                    break;

                case '2':
                    alert( 'Два' );
                    break;

                case 3:
                    alert( 'Никогда не выполнится!' );
                    break;
                default:
                    alert( 'Неизвестное значение' );
            }
        </pre>

        <p>Возможность группировать <code>case</code> – это побочный эффект того, как <code>switch/case</code> работает без <code>break</code>. </p>
        <ul class="ul_num">
            <li>Для <code>'0'</code> и <code>'1'</code> выполнится первый <code>alert</code>.</li>
            <li>Для <code>'2'</code> – второй <code>alert</code>.</li>
            <li>Проверка на равенство всегда строгая. Поэтому для <code>3</code>, результат выполнения prompt будет строка <code>"3"</code>, которая не соответствует строгому равенству <code>===</code> с числом <code>3</code>. Таким образом, мы имеем «мёртвый код» в <code>case 3</code>! Выполнится вариант <code>default</code>.</li>
        </ul>
    </div>


    <div class="linear" id="function-basics">
        <h1>Функции</h1>

        <h2>Параметры по умолчанию</h2>

        <p>Если мы хотим задать параметру <code>text</code> значение по умолчанию, мы должны указать его после <code>=</code>:</p>

        <pre class="brush: js;">
            function showMessage(from, text = "текст не добавлен") {
                alert( from + ": " + text );
            }

            showMessage("Аня"); // Аня: текст не добавлен
        </pre>

        <p>Теперь, если параметр <code>text</code> не указан, его значением будет <code>"текст не добавлен"</code>. Или любое другое значение, которое мы укажем. Например можем указать вызов функции, которя вернет какое то значение.</p>


        <h2>Возврат значения</h2>

        <p>Функция может вернуть результат, который будет передан в вызвавший её код.</p>

        <pre class="brush: js;">
            function sum(a, b) {
                return a + b;
            }

            let result = sum(1, 2);
            alert( result ); // 3
        </pre>

        <p>Директива <code>return</code> может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной <code>result</code> выше). Остальной код после <code>return</code> не выполняется.</p>

        <p>Использовать <code>return</code> можно и без значения. Это приведёт к немедленному выходу из функции.</p>

        <pre class="brush: js;">
            function showMovie(age) {
                if ( !checkAge(age) ) {
                    return;
                }

                alert( "Вам показывается кино" ); // если checkAge(age) вернёт false, showMovie не выполнит alert.
            }
        </pre>

    </div>


    <div class="linear" id="function-expressions-arrows">
        <h1>Function Expression и функции-стрелки</h1>


        <pre class="brush: js;">
            function sayHi() {   // (1) создаём
                alert( "Привет" );
            }

            let func = sayHi;    // (2) копируем

            func(); // Привет       // (3) вызываем копию (работает)!
            sayHi(); // Привет      // прежняя тоже работает (почему бы нет)
            alert( sayHi );         // выведет код функции


            //=====================


            //Function Expression (Функциональное Выражение)
            let sayHi = function() {
                alert( "Привет" );
            };                          //В этом случае потребуется точка с запятой (;), т.к. это не блок кода, а выражение с присваиванием.
        </pre>

        <p>По сути без разницы, как мы определили функцию, это просто значение.</p>


        <h2>Функции-«колбэки»</h2>

        <p>Наша функция должна задать вопрос <code>question</code> и, в зависимости от того, как ответит пользователь, вызвать <code>yes()</code> или <code>no()</code>:</p>

        <pre class="brush: js;">
            function ask(question, yes, no) {
                if (confirm(question)) yes()
                else no();
            }

            function showOk() {
                alert( "Вы согласны." );
            }

            function showCancel() {
                alert( "Вы отменили выполнение." );
            }

            // использование: функции showOk, showCancel передаются в качестве аргументов ask
            ask("Вы согласны?", showOk, showCancel);
        </pre>

        <p><b>Аргументы функции ask ещё называют функциями-колбэками или просто колбэками.</b></p>

        <p>Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо. В нашем случае, <code>showOk</code> становится <i>колбэком</i>’ для ответа «yes», а <code>showCancel</code> – для ответа «no».</p>

        <p>Мы можем переписать этот пример значительно короче, используя Function Expression:</p>

        <pre class="brush: js;">
            function ask(question, yes, no) {
                if (confirm(question)) yes()
                else no();
            }

            ask(
                "Вы согласны?",
                function() { alert("Вы согласились."); },
                function() { alert("Вы отменили выполнение."); }
            );
        </pre>

        <p>Мы можем передавать функции из переменной в переменную и запускать, когда захотим.</p>


        <h2>Функции-стрелки</h2>

        <pre class="brush: js;">
            let sum = (a, b) => a + b;

            /* Функция-стрелка более краткая форма для:

            let sum = function(a, b) {
                return a + b;
            };
            */

            alert( sum(1, 2) ); // 3
        </pre>

        <p>Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:</p>

        <pre class="brush: js;">
            // тоже что и
            // let double = function(n) { return n * 2 }
            let double = n => n * 2;

            alert( double(3) ); // 6
        </pre>

        <p>Если нет аргументов, используются пустые круглые скобки (их указывать обязательно):</p>

        <pre class="brush: js;">
            let sayHi = () => alert("Hello!");

            sayHi();
        </pre>

        <p><b>Пример:</b></p>

        <pre class="brush: js;">
            let age = prompt("Сколько Вам лет?", 18);

            let welcome = (age < 18) ?
              () => alert('Привет') :
              () => alert("Здравствуйте!");

            welcome();
        </pre>

        <p><b>Многострочные стрелочные функции</b></p>

        <pre class="brush: js;">
            let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
                let result = a + b;
                return result; // при фигурных скобках нужен return, чтобы вернуть результат
            };

            alert( sum(1, 2) ); // 3
        </pre>

        <h2>Итого:</h2>

        <ul class="ul_num">
            <li>
                <p>Function Declaration: функция в основном потоке кода</p>
                <pre class="brush: js;">
                    function sum(a, b) {
                        let result = a + b;

                        return result;
                    }
                </pre>
            </li>
            <li>
                <p>Function Expression: функция как часть выражения</p>
                <pre class="brush: js;">
                    let sum = function(a, b) {
                        let result = a + b;

                        return result;
                    };
                </pre>
            </li>
            <li>
                <p>Стрелочные функции:</p>
                <pre class="brush: js;">
                    // выражение в правой части
                    let sum = (a, b) => a + b;

                    // многострочный код в фигурных скобках { ... }, здесь нужен return:
                    let sum = (a, b) => {
                        // ...
                        return a + b;
                    }

                    // без аргументов
                    let sayHi = () => alert("Привет");

                    // с одним аргументом
                    let double = n => n * 2;
                </pre>
            </li>
        </ul>

    </div>

<!--

    <div class="linear" id="use_strict">
        <h1>11111111111111111</h1>

        <h2>2222222222222222/h2>


        <p>3333333333333333333</p>

        <pre class="brush: js;">

        </pre>

        <ul class="ul_num">
            <li>44444444444444444444</li>

        </ul>

    </div>

-->



<?php include '../include/footer.php'; ?>
